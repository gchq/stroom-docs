---
title: "Content Providers"
linkTitle: "Content Providers"
weight: 10
date: 2021-07-27
tags: 
description: >
  
---

Content providers take some content from the input source or elsewhere (see [fixed strings]({{< relref "use-of-fixed-strings.md" >}}) and provide it to one or more expressions.
Both the root element `<dataSplitter>` and `<group>` elements are content providers.

## Root element `<dataSplitter>`

The root element of a Data Splitter configuration is `<dataSplitter>`.
It supplies content from the input source to one or more expressions defined within it.
The way that content is buffered is controlled by the root element and the way that errors are handled as a result of child expressions not matching all of the content it supplies.

### Attributes

The following attributes can be added to the `<dataSplitter>` root element:

* [`ignoreErrors`]({{< relref "#datasplitter-ignoreerrors" >}})
* [`bufferSize`]({{< relref "#buffersize-advanced" >}})

#### `ignoreErrors` {#datasplitter-ignoreerrors}

Data Splitter generates errors if not all of the content is matched by the regular expressions beneath the `<dataSplitter>` or within `<group>` elements.
The error messages are intended to aid the user in writing good Data Splitter configurations.
The intent is to indicate when the input data is not being matched fully and therefore possibly skipping some important data.
Despite this, in some cases it is laborious to have to write expressions to match all content.
In these cases it is preferable to add this attribute to ignore these errors.
However it is often better to write expressions that capture all of the supplied content and discard unwanted characters.
This attribute also affects errors generated by the use of the `minMatch` attribute on `<regex>` which is described later on.

Take the following example input:

```text
Name1,Name2,Name3
value1,value2,value3 # a useless comment
value1,value2,value3 # a useless comment 
```

This could be matched with the following configuration:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<dataSplitter
    xmlns="data-splitter:3"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="data-splitter:3 file://data-splitter-v3.0.xsd"
    version="3.0">
  <regex id="heading" pattern=".+" maxMatch="1">
…
  </regex>
  <regex id="body" pattern="\n[^#]+">
…
  </regex>
</dataSplitter>
```

The above configuration would only match up to a comment for each record line, e.g.

```text
Name1,Name2,Name3
value1,value2,value3 # a useless comment
value1,value2,value3 # a useless comment
```

This may well be the desired functionality but if there was useful content within the comment it would be lost.
Because of this Data Splitter warns you when expressions are failing to match all of the content presented so that you can make sure that you aren't missing anything important.
In the above example it is obvious that this is the required behaviour but in more complex cases you might be otherwise unaware that your expressions were losing data.

To maintain this assurance that you are handling all content it is usually best to write expressions to explicitly match all content even though you may do nothing with some matches, e.g.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<dataSplitter
    xmlns="data-splitter:3"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="data-splitter:3 file://data-splitter-v3.0.xsd"
    version="3.0">
  <regex id="heading" pattern=".+" maxMatch="1">
…
  </regex>
  <regex id="body" pattern="\n([^#]+)#.+">
…
  </regex>
</dataSplitter>
```

The above example would match all of the content and would therefore not generate warnings.
Sub-expressions of 'body' could use match group 1 and ignore the comment.

However as previously stated it might often be difficult to write expressions that will just match content that is to be discarded.
In these cases `ignoreErrors` can be used to suppress errors caused by unmatched content.

#### `bufferSize` (Advanced)

This is an optional attribute used to tune the size of the character buffer used by Data Splitter.
The default size is 20000 characters and should be fine for most translations.
The minimum value that this can be set to is 20000 characters and the maximum is 1000000000.
The only reason to specify this attribute is when individual records are bigger than 10000 characters which is rarely the case.

## Group element `<group>`

Groups behave in a similar way to the root element in that they provide content for one or more inner expressions to deal with, e.g.

```xml
<group value="$1">
  <regex pattern="([^\t]*)\t([^\t]*)[\t]*([^=:]*)[=:]*(.*)" maxMatch="1">
  ...
  <regex pattern="([^\t]*)\t([^\t]*)[\t]*([^=:]*)[=:]*(.*)">
  ...
```

### Attributes

As the `<group>` element is a content provider it also includes the same `ignoreErrors` attribute which behaves in the same way.
The complete list of attributes for the `<group>` element is as follows:

* [`id`]({{< relref "#id" >}})
* [`value`]({{< relref "#value" >}})
* [`ignoreErrors`]({{< relref "#group-ignoreerrors" >}})
* [`matchOrder`]({{< relref "#matchorder" >}})
* [`reverse`]({{< relref "#reverse" >}})

#### `id`

When Data Splitter reports errors it outputs an XPath to describe the part of the configuration that generated the error, e.g.

```text
DSParser [2:1] ERROR: Expressions failed to match all of the content provided by group: regex[0]/group[0]/regex[3]/group[1] : <group>
```

It is often a little difficult to identify the configuration element that generated the error by looking at the path and the element description, particularly when multiple elements are the same, e.g. many `<group>` elements without attributes.
To make identification easier you can add an 'id' attribute to any element in the configuration resulting in error descriptions as follows:

```text
DSParser [2:1] ERROR: Expressions failed to match all of the content provided by group: regex[0]/group[0]/regex[3]/group[1] : <group id="myGroupId">
```

#### `value`

This attribute determines what content to present to child expressions.
By default the entire content matched by a group’s parent expression is passed on by the group to child expressions.
If required, content from a specific match group in the parent expression can be passed to child expressions using the value attribute, e.g. `value="$1"`.
In addition to this content can be composed in the same way as it is for data names and values.

{{% see-also %}}
[Match references]({{< relref "../match-reference" >}}) for a full description of match references.
{{% /see-also %}}


#### `ignoreErrors` {#group-ignoreerrors}

This behaves in the same way as for the root element.

#### `matchOrder`

This is an optional attribute used to control how content is consumed by expression matches.
Content can be consumed in sequence or in any order using `matchOrder="sequence"` or `matchOrder="any"`.
If the attribute is not specified, Data Splitter will default to matching in sequence.

When matching in sequence, each match consumes some content and the content position is moved beyond the match ready for the subsequent match.
However, in some cases the order of these constructs is not predictable, e.g. we may sometimes be presented with:

```text
Value1=1 Value2=2
```

… or sometimes with:

```text
Value2=2 Value1=1
```

Using a sequential match order the following example would work to find both values in `Value1=1 Value2=2`

```xml
<group>
  <regex pattern="Value1=([^ ]*)">
  ...
  <regex pattern="Value2=([^ ]*)">
  ...
```

… but this example would skip over Value2 and only find the value of Value1 if the input was `Value2=2 Value1=1`.

To be able to deal with content that contains these constructs in either order we need to change the match order to `any`.

When matching in any order, each match removes the matched section from the content rather than moving the position past the match so that all remaining content can be matched by subsequent expressions.
In the following example the first expression would match and remove `Value1=1` from the supplied content and the second expression would be presented with ` Value2=2` which it could also match.

```xml
<group matchOrder="any">
  <regex pattern="Value1=([^ ]*)">
  ...
  <regex pattern="Value2=([^ ]*)">
  ...
```

If the attribute is omitted by default the match order will be sequential.
This is the default behaviour as tokens are most often in sequence and consuming content in this way is more efficient as content does not need to be copied by the parser to chop out sections as is required for matching in any order.
It is only necessary to use this feature when fields that are identifiable with a specific match can occur in any order.

#### `reverse`

Occasionally it is desirable to reverse the content presented by a group to child expressions. This is because it is sometimes easier to form a pattern by matching content in reverse.

Take the following example content of name, value pairs delimited by `=` but with no spaces between names, multiple spaces between values and only a space between subsequent pairs:

```text
ipAddress=123.123.123.123 zones=Zone 1, Zone 2, Zone 3 location=loc1 A user=An end user serverName=bigserver
```

We could write a pattern that matches each name value pair by matching up to the start of the next name, e.g.

```xml
<regex pattern="([^=]+)=(.+?)( [^=]+=)">
```

This would match the following:

```text
ipAddress=123.123.123.123 zones=
```

Here we are capturing the name and value for each pair in separate groups but the pattern has to also match the name from the next name value pair to find the end of the value. By default Data Splitter will move the content buffer to the end of the match ready for subsequent matches so the next name will not be available for matching.

In addition to matching too much content the above example also uses a reluctant qualifier `.+?`. Use of reluctant qualifiers almost always impacts performance so they are to be avoided if at all possible.

A better way to match the example content is to match the input in reverse, reading characters from right to left.

The following example demonstrates this:

```xml
<group reverse="true">
  <regex pattern="([^=]+)=([^ ]+)">
    <data name="$2" value="$1" />
  </regex>
</group>
```

Using the reverse attribute on the parent group causes content to be supplied to all child expressions in reverse order. In the above example this allows the pattern to match values followed by names which enables us to cope with the fact that values have multiple spaces but names have no spaces.

Content is only presented to child regular expressions in reverse. When referencing values from match groups the content is returned in the correct order, e.g. the above example would return:

```xml
<data name="ipAddress" value="123.123.123.123" />
<data name="zones" value="Zone 1, Zone 2, Zone 3" />
<data name="location" value="loc1" />
<data name="user" value="An end user" />
<data name="serverName" value="bigserver" />
```

The reverse feature isn't needed very often but there are a few cases where it really helps produce the desired output without the complexity and performance overhead of a reluctant match.

An alternative to using the reverse attribute is to use the original reluctant expression example but tell Data Splitter to make the subsequent name available for the next match by not advancing the content beyond the end of the previous value. This is done by using the [advance attribute]({{< relref "expressions.md#regex-advance" >}}) on the `<regex>`. However, the reverse attribute represents a better way to solve this particular problem and allows a simpler and more efficient regular expression to be used.
