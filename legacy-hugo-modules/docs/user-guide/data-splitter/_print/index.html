<!doctype html>
<html lang="en" class="no-js">
  <head>
    
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="generator" content="Hugo 0.95.0" />
<link rel="canonical" type="text/html" href="../../../../docs/user-guide/data-splitter/">
<meta name="robots" content="noindex, nofollow">


<link rel="shortcut icon" href="../../../../favicons/favicon.ico" >
<link rel="apple-touch-icon" href="../../../../favicons/apple-touch-icon-180x180.png" sizes="180x180">
<link rel="icon" type="image/png" href="../../../../favicons/favicon-16x16.png" sizes="16x16">
<link rel="icon" type="image/png" href="../../../../favicons/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="../../../../favicons/android-36x36.png" sizes="36x36">
<link rel="icon" type="image/png" href="../../../../favicons/android-48x48.png" sizes="48x48">
<link rel="icon" type="image/png" href="../../../../favicons/android-72x72.png" sizes="72x72">
<link rel="icon" type="image/png" href="../../../../favicons/android-96x96.png" sizes="96x96">
<link rel="icon" type="image/png" href="../../../../favicons/android-144x144.png" sizes="144x144">
<link rel="icon" type="image/png" href="../../../../favicons/android-192x192.png" sizes="192x192">

<title>Data Splitter | Stroom</title>
<meta name="description" content="Data Splitter was created to transform text into XML. The XML produced is basic but can be processed further with XSLT to form any desired XML output. …">
<meta property="og:title" content="Data Splitter" />
<meta property="og:description" content="Stroom documentation, release notes, news and open source community information" />
<meta property="og:type" content="website" />
<meta property="og:url" content="/docs/user-guide/data-splitter/" /><meta property="og:site_name" content="Stroom" />

<meta itemprop="name" content="Data Splitter">
<meta itemprop="description" content="Stroom documentation, release notes, news and open source community information"><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Data Splitter"/>
<meta name="twitter:description" content="Stroom documentation, release notes, news and open source community information"/>





<link href="../../../../scss/main.css" rel="stylesheet">


<script src='../../../../js/jquery-3.6.0.min.js'></script>


<script src='../../../../js/lunr.min.js'></script>
  
<link rel="stylesheet" href="../../../../css/prism.css"/>

  </head>
  <body class="td-section">
    <header>
      
<nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar">
        <a class="navbar-brand" href="../../../../">
		<span class="navbar-logo"><svg xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:cc="http://creativecommons.org/ns#" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" width="110.61089" height="30.000004" viewBox="0 0 88.488641 23.999957" id="svg2" inkscape:version="0.91 r13725" sodipodi:docname="logo.svg"><defs id="defs20"/><sodipodi:namedview pagecolor="#989898" bordercolor="#666666" borderopacity="1" objecttolerance="10" gridtolerance="10" guidetolerance="10" inkscape:pageopacity="0" inkscape:pageshadow="2" inkscape:window-width="1920" inkscape:window-height="1137" id="namedview18" showgrid="false" fit-margin-top="0" fit-margin-left="0" fit-margin-right="0" fit-margin-bottom="0" inkscape:zoom="5.5951814" inkscape:cx="55.451414" inkscape:cy="16.275348" inkscape:window-x="0" inkscape:window-y="0" inkscape:window-maximized="1" inkscape:current-layer="svg2"/><g id="g4150" style="opacity:.97000002" transform="matrix(0.03883584,0,0,0.03883584,0,-3.1155874e-4)"><path id="path6" d="M121.99991 205.98497C54.999958 205.98497.0 259.98493.0 327.98487c0 66.99994 54.999958 121.99989 121.99991 121.99989h167.99987c24.99998.0 44.99996 20.99998 44.99996 44.99996.0 24.99998-19.99998 44.99996-44.99996 44.99996H109.20929C65.984126 553.87219 27.100843 581.57313.01093599 617.98462H289.99978c66.99994.0 121.99991-54.99996 121.99991-122.9999.0-66.99994-54.99997-121.99989-121.99991-121.99989H121.99991c-24.999984.0-44.999969-19.99999-44.999969-44.99996.0-24.99998 19.999985-44.99996 44.999969-44.99996h228.79045c26.9905-35.88325 65.47093-63.18547 108.21554-76.99994H121.99991z" style="fill:#fff" inkscape:connector-curvature="0"/><path id="path8" d="M601.44485-.00077860649C572.6583 8.3697982 546.49491 22.822962 524.44491 41.902305V205.78969l.002.19528h-.002c-65.11 48e-5-123.03145 30.0199-160.74675 76.99994h160.74675v334.99971h76.99994V282.98491h144.85298c27.16134-36.05885 65.96411-63.39275 109.02184-76.99994H601.44485v-205.98574860649z" style="fill:#fff" inkscape:connector-curvature="0"/><path id="path10" d="m919.42586 205.98497c-113.99519.0-205.99537 92.00648-206.00296 205.99982-15e-5 68.67178.0 137.32749.0 205.99983h77.99994c-.012-68.6493.0176-137.46869.0-205.99983.0846-70.92785 57.05747-128.99988 128.00462-128.99988 5.28623.0 10.49823.32864 15.62183.95311 18.2219-24.51229 41.78461-45.0838 68.42501-60.15146-25.65065-11.43799-54.08662-17.80159-84.04684-17.80159z" style="fill:#fff" inkscape:connector-curvature="0"/><path id="path12" d="m1109.4153 205.98457c-113.99994.0-205.99983 91.99993-205.99983 205.99984.0 112.9999 91.99989 205.9998 205.99983 205.9998 114 0 205.9999-92.9999 205.9999-205.9998.0-113.99991-91.9999-205.99984-205.9999-205.99984zm0 333.99974c-70.9999.0-128.99994-56.99996-128.99994-127.9999.0-70.99995 58.00004-128.9999 128.99994-128.9999 71 0 128.9999 57.99995 128.9999 128.9999.0 70.99994-57.9999 127.9999-128.9999 127.9999z" style="fill:#fff" inkscape:connector-curvature="0"/><path id="path14" d="m1444.4737 205.98457c-113.9999.0-205.9998 91.99993-205.9998 205.99984.0 112.9999 91.9999 205.9998 205.9998 205.9998s205.9999-92.9999 205.9999-205.9998c0-113.99991-92-205.99984-205.9999-205.99984zm0 333.99974c-70.9999.0-128.9999-56.99996-128.9999-127.9999.0-70.99995 58-128.9999 128.9999-128.9999 71 0 128.9999 57.99995 128.9999 128.9999.0 70.99994-57.9999 127.9999-128.9999 127.9999z" style="fill:#fff" inkscape:connector-curvature="0"/><path id="path16" d="m1738.5308 379.98447c0-53 43-97 95.9999-97 53 0 97 44 97 97v237.9997h76.9999v-237.9997c0-53 43-97 96.9999-97 53 0 95.9999 44 95.9999 97v237.9997h77v-237.9997c0-96-77-173.9999-172.9999-173.9999-54.9999.0-103.9999 24.99998-135.9999 64.99995-31.9999-39.99997-79.9999-64.99995-134.9999-64.99995-95.9999.0-173.9998 77.9999-173.9998 173.9999v237.9997h77.9999z" style="fill:#fff" inkscape:connector-curvature="0"/></g></svg></span><span class="font-weight-bold">Stroom</span>
	</a>
	<div class="td-navbar-nav-scroll ml-md-auto" id="main_navbar">
		<ul class="navbar-nav mt-2 mt-lg-0">
			
			
			<li class="nav-item mr-4 mb-2 mb-lg-0">
				
				
				
				
				
				
				
				
				<a class="nav-link" href="../../../../about/about/" ><span>About</span></a>
			</li>
			
			<li class="nav-item mr-4 mb-2 mb-lg-0">
				
				
				
				
				
				
				
				
				<a class="nav-link active" href="../../../../docs/" ><span class="active">Documentation</span></a>
			</li>
			
			<li class="nav-item mr-4 mb-2 mb-lg-0">
				
				
				
				
				
				
				
				
				<a class="nav-link" href="../../../../community/" ><span>Community</span></a>
			</li>
			
			
			<li class="nav-item dropdown mr-4 d-none d-lg-block">
				<a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
	Stroom Version (Legacy)
</a>
<div class="dropdown-menu" aria-labelledby="navbarDropdownMenuLink">
	
	<a class="dropdown-item" href="../../../../../7.1">7.1</a>
	
	<a class="dropdown-item" href="../../../../../7.0">7.0</a>
	
	<a class="dropdown-item" href="../../../../../legacy">Legacy</a>
	
</div>

			</li>
			
			
		</ul>
	</div>
	<div class="navbar-nav d-none d-lg-block"><input
  type="search"
  class="form-control td-search-input"
  placeholder="&#xf002; Search this site…"
  aria-label="Search this site…"
  autocomplete="off"
  
  data-offline-search-index-json-src="../../../../offline-search-index.json"
  data-offline-search-base-href="../../../../"
  data-offline-search-max-results="50"
>
</div>
</nav>

    </header>
    <div class="container-fluid td-outer">
      <div class="td-main">
        <div class="row flex-xl-nowrap">
          <main class="col-12 col-md-9 col-xl-8 pl-md-5" role="main">
            




<div class="td-content">
<div class="pageinfo pageinfo-primary d-print-none">
<p>
This is the multi-page printable view of this section.
<a href="#" onclick="print();return false;">Click here to print</a>.
</p><p>
<a href="../../../../docs/user-guide/data-splitter/">Return to the regular view of this page</a>.
</p>
</div>



<h1 class="title">Data Splitter</h1>





    <ul>
    
  
  
  
  

  
    
    
	
<li>1: <a href="#pg-48e91d41ce117850b608db5bec356e50">Simple CSV Example</a></li>


    
  
    
    
	
<li>2: <a href="#pg-60e04cb943539552c26ef441163ec991">Simple CSV example with heading</a></li>


    
  
    
    
	
<li>3: <a href="#pg-d7c86891e32034cff23f52e772d0957b">Complex example with regex and user defined names</a></li>


    
  
    
    
	
<li>4: <a href="#pg-4e7eb119df912b5530510cddfbbe36eb">Multi Line Example</a></li>


    
  
    
    
	
<li>5: <a href="#pg-8f4175cc7d3f7d584edb7958e8546094">Element Reference</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>5.1: <a href="#pg-433f7e66c8f749c136edf8dd77485021">Content Providers</a></li>


    
  
    
    
	
<li>5.2: <a href="#pg-002b4e409b3795e26b4c2c408449ace2">Expressions</a></li>


    
  
    
    
	
<li>5.3: <a href="#pg-7a65167c519705ee561f6d7d28e6dd8a">Output</a></li>


    
  
    
    
	
<li>5.4: <a href="#pg-51f3f0c126598dfdbe243f6ba10324b0">Variables</a></li>


    
  

    </ul>
    
  
    
    
	
<li>6: <a href="#pg-aaf101b97e91090cfb3df1bcf42a141a">Match References, Variables and Fixed Strings</a></li>


    
    <ul>
        
  
  
  
  

  
    
    
	
<li>6.1: <a href="#pg-3b82e13ffa085113005df16df1cec517">Concatenation of references</a></li>


    
  
    
    
	
<li>6.2: <a href="#pg-1634da39a3ac0fbcef0aa75957192611">Expression match references</a></li>


    
  
    
    
	
<li>6.3: <a href="#pg-bcb29e33caf02d50bf39e0cfeb4ecb3b">Use of fixed strings</a></li>


    
  
    
    
	
<li>6.4: <a href="#pg-ad6ae2faaa3721b740dceefffaf34916">Variable reference</a></li>


    
  

    </ul>
    
  

    </ul>


<div class="content">
      <p>Data Splitter was created to transform text into XML. The XML produced is basic but can be processed further with XSLT to form any desired XML output.</p>
<p>Data Splitter works by using regular expressions to match a region of content or tokenizers to split content. The whole match or match group can then be output or passed to other expressions to further divide the matched data.</p>
<p>The root <code>&lt;dataSplitter&gt;</code> element controls the way content is read and buffered from the source. It then passes this content on to one or more child expressions that attempt to match the content. The child expressions attempt to match content one at a time in the order they are specified until one matches. The matching expression then passes the content that it has matched to other elements that either emit XML or apply other expressions to the content matched by the parent.</p>
<p>This process of content supply, match, (supply, match)*, emit is best illustrated in a simple CSV example. Note that the elements and attributes used in all examples are explained in detail in the <a href="../../../../docs/user-guide/data-splitter/element-reference/">element reference</a>.</p>

</div>
</div>


  
  
  
  

  
  

  
    
    
	
    



<div class="td-content" style="--base-section-num: '1.'; page-break-before: always">
    
  <h1 id="pg-48e91d41ce117850b608db5bec356e50">1 - Simple CSV Example</h1>
    
	<p>The following CSV data will be split up into separate fields using Data Splitter.</p>
<pre><code class="language-csv">01/01/2010,00:00:00,192.168.1.100,SOMEHOST.SOMEWHERE.COM,user1,logon,
01/01/2010,00:01:00,192.168.1.100,SOMEHOST.SOMEWHERE.COM,user1,create,c:\test.txt
01/01/2010,00:02:00,192.168.1.100,SOMEHOST.SOMEWHERE.COM,user1,logoff,
</code></pre>
<p>The first thing we need to do is match each record. Each record in a CSV file is delimited by a new line character. The following configuration will split the data into records using ‘\n’ as a delimiter:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;
  
  &lt;!-- Match each line using a new line character as the delimiter --&gt;
  &lt;split delimiter=&quot;\n&quot;/&gt;

&lt;/dataSplitter&gt;
</code></pre>
<p>In the above example the ‘split’ tokenizer matches all of the supplied content up to the end of each line ready to pass each line of content on for further treatment.</p>
<p>We can now add a <code>&lt;group&gt;</code> element within <code>&lt;split&gt;</code> to take content matched by the tokenizer.</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;

  &lt;!-- Match each line using a new line character as the delimiter --&gt;
  &lt;split delimiter=&quot;\n&quot;&gt;

    &lt;!-- Take the matched line (using group 1 ignores the delimiters, 
    without this each match would include the new line character) --&gt;
    &lt;group value=&quot;$1&quot;&gt;

    &lt;/group&gt;
  &lt;/split&gt;
&lt;/dataSplitter&gt;
</code></pre>
<p>The <code>&lt;group&gt;</code> within the <code>&lt;split&gt;</code> chooses to take the content from the <code>&lt;split&gt;</code> without including the new line &lsquo;\n&rsquo; delimiter by using match group 1, see <a href="../../../../docs/user-guide/data-splitter/match-reference/3-1-expression-match-references/#sec-3-1-1">expression match references</a> for details.</p>
<pre><code class="language-text">01/01/2010,00:00:00,192.168.1.100,SOMEHOST.SOMEWHERE.COM,user1,logon,
</code></pre>
<p>The content selected by the <code>&lt;group&gt;</code> from its parent match can then be passed onto sub expressions for further matching:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;

  &lt;!-- Match each line using a new line character as the delimiter --&gt;
  &lt;split delimiter=&quot;\n&quot;&gt;

    &lt;!-- Take the matched line (using group 1 ignores the delimiters, 
    without this each match would include the new line character) --&gt;
    &lt;group value=&quot;$1&quot;&gt;

      &lt;!-- Match each value separated by a comma as the delimiter --&gt;
      &lt;split delimiter=&quot;,&quot;&gt;

      &lt;/split&gt;
    &lt;/group&gt;
  &lt;/split&gt;
&lt;/dataSplitter&gt;
</code></pre>
<p>In the above example the additional <code>&lt;split&gt;</code> element within the <code>&lt;group&gt;</code> will match the content provided by the group repeatedly until it has used all of the group content.</p>
<p>The content matched by the inner <code>&lt;split&gt;</code> element can be passed to a <code>&lt;data&gt;</code> element to emit XML content.</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;

  &lt;!-- Match each line using a new line character as the delimiter --&gt;
  &lt;split delimiter=&quot;\n&quot;&gt;

    &lt;!-- Take the matched line (using group 1 ignores the delimiters, 
    without this each match would include the new line character) --&gt;
    &lt;group value=&quot;$1&quot;&gt;

      &lt;!-- Match each value separated by a comma as the delimiter --&gt;
      &lt;split delimiter=&quot;,&quot;&gt;

        &lt;!-- Output the value from group 1 (as above using group 1
        ignores the delimiters, without this each value would include
        the comma) --&gt;
        &lt;data value=&quot;$1&quot; /&gt;
      &lt;/split&gt;
    &lt;/group&gt;
  &lt;/split&gt;
&lt;/dataSplitter&gt;
</code></pre>
<p>In the above example each match from the inner <code>&lt;split&gt;</code> is made available to the inner <code>&lt;data&gt;</code> element that chooses to output content from match group 1, see <a href="../../../../docs/user-guide/data-splitter/match-reference/3-1-expression-match-references/#sec-3-1-1">expression match references</a> for details.</p>
<p>The above configuration results in the following XML output for the whole input:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;records xmlns=&quot;records:2&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;records:2 file://records-v2.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;record&gt;
    &lt;data value=&quot;01/01/2010&quot; /&gt;
    &lt;data value=&quot;00:00:00&quot; /&gt;
    &lt;data value=&quot;192.168.1.100&quot; /&gt;
    &lt;data value=&quot;SOMEHOST.SOMEWHERE.COM&quot; /&gt;
    &lt;data value=&quot;user1&quot; /&gt;
    &lt;data value=&quot;logon&quot; /&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data value=&quot;01/01/2010&quot; /&gt;
    &lt;data value=&quot;00:01:00&quot; /&gt;
    &lt;data value=&quot;192.168.1.100&quot; /&gt;
    &lt;data value=&quot;SOMEHOST.SOMEWHERE.COM&quot; /&gt;
    &lt;data value=&quot;user1&quot; /&gt;
    &lt;data value=&quot;create&quot; /&gt;
    &lt;data value=&quot;c:\test.txt&quot; /&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data value=&quot;01/01/2010&quot; /&gt;
    &lt;data value=&quot;00:02:00&quot; /&gt;
    &lt;data value=&quot;192.168.1.100&quot; /&gt;
    &lt;data value=&quot;SOMEHOST.SOMEWHERE.COM&quot; /&gt;
    &lt;data value=&quot;user1&quot; /&gt;
    &lt;data value=&quot;logoff&quot; /&gt;
  &lt;/record&gt;
&lt;/records&gt;
</code></pre>

</div>




    
	
  
    
    
	
    



<div class="td-content" style="--base-section-num: '2.'; page-break-before: always">
    
  <h1 id="pg-60e04cb943539552c26ef441163ec991">2 - Simple CSV example with heading</h1>
    
	<p>In addition to referencing content produced by a parent element it is often desirable to store content and reference it later. The following example of a CSV with a heading demonstrates how content can be stored in a variable and then referenced later on.</p>
<h2 id="a-namesec_1_2_1ainput"><a name="sec_1_2_1"></a>Input</h2>
<p>This example will use a similar input to the one in the previous CSV example but also adds a heading line.</p>
<pre><code class="language-text">Date,Time,IPAddress,HostName,User,EventType,Detail
01/01/2010,00:00:00,192.168.1.100,SOMEHOST.SOMEWHERE.COM,user1,logon,
01/01/2010,00:01:00,192.168.1.100,SOMEHOST.SOMEWHERE.COM,user1,create,c:\test.txt
01/01/2010,00:02:00,192.168.1.100,SOMEHOST.SOMEWHERE.COM,user1,logoff,
</code></pre>
<h2 id="a-namesec_1_2_2aconfiguration"><a name="sec_1_2_2"></a>Configuration</h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;

  &lt;!-- Match heading line (note that maxMatch=&quot;1&quot; means that only the
  first line will be matched by this splitter) --&gt;
  &lt;split delimiter=&quot;\n&quot; maxMatch=&quot;1&quot;&gt;

    &lt;!-- Store each heading in a named list --&gt;
    &lt;group&gt;
      &lt;split delimiter=&quot;,&quot;&gt;
        &lt;var id=&quot;heading&quot; /&gt;
      &lt;/split&gt;
    &lt;/group&gt;
  &lt;/split&gt;

  &lt;!-- Match each record --&gt;
  &lt;split delimiter=&quot;\n&quot;&gt;

    &lt;!-- Take the matched line --&gt;
    &lt;group value=&quot;$1&quot;&gt;

      &lt;!-- Split the line up --&gt;
      &lt;split delimiter=&quot;,&quot;&gt;

        &lt;!-- Output the stored heading for each iteration and the value
        from group 1 --&gt;
        &lt;data name=&quot;$heading$1&quot; value=&quot;$1&quot; /&gt;
      &lt;/split&gt;
    &lt;/group&gt;
  &lt;/split&gt;
&lt;/dataSplitter&gt;
</code></pre>
<h2 id="a-namesec_1_2_3aoutput"><a name="sec_1_2_3"></a>Output</h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;records xmlns=&quot;records:2&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;records:2 file://records-v2.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;record&gt;
    &lt;data name=&quot;Date&quot; value=&quot;01/01/2010&quot; /&gt;
    &lt;data name=&quot;Time&quot; value=&quot;00:00:00&quot; /&gt;
    &lt;data name=&quot;IPAddress&quot; value=&quot;192.168.1.100&quot; /&gt;
    &lt;data name=&quot;HostName&quot; value=&quot;SOMEHOST.SOMEWHERE.COM&quot; /&gt;
    &lt;data name=&quot;User&quot; value=&quot;user1&quot; /&gt;
    &lt;data name=&quot;EventType&quot; value=&quot;logon&quot; /&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data name=&quot;Date&quot; value=&quot;01/01/2010&quot; /&gt;
    &lt;data name=&quot;Time&quot; value=&quot;00:01:00&quot; /&gt;
    &lt;data name=&quot;IPAddress&quot; value=&quot;192.168.1.100&quot; /&gt;
    &lt;data name=&quot;HostName&quot; value=&quot;SOMEHOST.SOMEWHERE.COM&quot; /&gt;
    &lt;data name=&quot;User&quot; value=&quot;user1&quot; /&gt;
    &lt;data name=&quot;EventType&quot; value=&quot;create&quot; /&gt;
    &lt;data name=&quot;Detail&quot; value=&quot;c:\test.txt&quot; /&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data name=&quot;Date&quot; value=&quot;01/01/2010&quot; /&gt;
    &lt;data name=&quot;Time&quot; value=&quot;00:02:00&quot; /&gt;
    &lt;data name=&quot;IPAdress&quot; value=&quot;192.168.1.100&quot; /&gt;
    &lt;data name=&quot;HostName&quot; value=&quot;SOMEHOST.SOMEWHERE.COM&quot; /&gt;
    &lt;data name=&quot;User&quot; value=&quot;user1&quot; /&gt;
    &lt;data name=&quot;EventType&quot; value=&quot;logoff&quot; /&gt;
  &lt;/record&gt;
&lt;/records&gt;
</code></pre>

</div>




    
	
  
    
    
	
    



<div class="td-content" style="--base-section-num: '3.'; page-break-before: always">
    
  <h1 id="pg-d7c86891e32034cff23f52e772d0957b">3 - Complex example with regex and user defined names</h1>
    
	<p>The following example uses a real world Apache log and demonstrates the use of regular expressions rather than simple &lsquo;split&rsquo; tokenizers. The usage and structure of regular expressions is outside of the scope of this document but Data Splitter uses Java&rsquo;s standard regular expression library that is POSIX compliant and documented in numerous places.</p>
<p>This example also demonstrates that the names and values that are output can be hard coded in the absence of field name information to make XSLT conversion easier later on. Also shown is that any match can be divided into further fields with additional expressions and the ability to nest data elements to provide structure if needed.</p>
<h2 id="a-namesec_1_3_1ainput"><a name="sec_1_3_1"></a>Input</h2>
<pre><code class="language-text">192.168.1.100 - &quot;-&quot; [12/Jul/2012:11:57:07 +0000] &quot;GET /doc.htm HTTP/1.1&quot; 200 4235 &quot;-&quot; &quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET4.0C; .NET4.0E; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)&quot;
192.168.1.100 - &quot;-&quot; [12/Jul/2012:11:57:07 +0000] &quot;GET /default.css HTTP/1.1&quot; 200 3494 &quot;http://some.server:8080/doc.htm&quot; &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET4.0C; .NET4.0E; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)&quot;
</code></pre>
<h2 id="a-namesec_1_3_2aconfiguration"><a name="sec_1_3_2"></a>Configuration</h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;

  &lt;!--
  Standard Apache Format

  %h - host name should be ok without quotes
  %l - Remote logname (from identd, if supplied). This will return a dash unless IdentityCheck is set On.
  \&quot;%u\&quot; - user name should be quoted to deal with DNs
  %t - time is added in square brackets so is contained for parsing purposes
  \&quot;%r\&quot; - URL is quoted
  %&gt;s - Response code doesn't need to be quoted as it is a single number
  %b - The size in bytes of the response sent to the client
  \&quot;%{Referer}i\&quot; - Referrer is quoted so that’s ok
  \&quot;%{User-Agent}i\&quot; - User agent is quoted so also ok

  LogFormat &quot;%h %l \&quot;%u\&quot; %t \&quot;%r\&quot; %&gt;s %b \&quot;%{Referer}i\&quot; \&quot;%{User-Agent}i\&quot;&quot; combined
  --&gt;

  &lt;!-- Match line --&gt;
  &lt;split delimiter=&quot;\n&quot;&gt;
    &lt;group value=&quot;$1&quot;&gt;

      &lt;!-- Provide a regular expression for the whole line with match
      groups for each field we want to split out --&gt;
      &lt;regex pattern=&quot;^([^ ]+) ([^ ]+) &amp;#34;([^&amp;#34;]+)&amp;#34; \[([^\]]+)] &amp;#34;([^&amp;#34;]+)&amp;#34; ([^ ]+) ([^ ]+) &amp;#34;([^&amp;#34;]+)&amp;#34; &amp;#34;([^&amp;#34;]+)&amp;#34;&quot;&gt;
        &lt;data name=&quot;host&quot; value=&quot;$1&quot; /&gt;
        &lt;data name=&quot;log&quot; value=&quot;$2&quot; /&gt;
        &lt;data name=&quot;user&quot; value=&quot;$3&quot; /&gt;
        &lt;data name=&quot;time&quot; value=&quot;$4&quot; /&gt;
        &lt;data name=&quot;url&quot; value=&quot;$5&quot;&gt;

          &lt;!-- Take the 5th regular expression group and pass it to
          another expression to divide into smaller components --&gt;
          &lt;group value=&quot;$5&quot;&gt;
            &lt;regex pattern=&quot;^([^ ]+) ([^ ]+) ([^ /]*)/([^ ]*)&quot;&gt;
              &lt;data name=&quot;httpMethod&quot; value=&quot;$1&quot; /&gt;
              &lt;data name=&quot;url&quot; value=&quot;$2&quot; /&gt;
              &lt;data name=&quot;protocol&quot; value=&quot;$3&quot; /&gt;
              &lt;data name=&quot;version&quot; value=&quot;$4&quot; /&gt;
            &lt;/regex&gt;
          &lt;/group&gt;
        &lt;/data&gt;
        &lt;data name=&quot;response&quot; value=&quot;$6&quot; /&gt;
        &lt;data name=&quot;size&quot; value=&quot;$7&quot; /&gt;
        &lt;data name=&quot;referrer&quot; value=&quot;$8&quot; /&gt;
        &lt;data name=&quot;userAgent&quot; value=&quot;$9&quot; /&gt;
      &lt;/regex&gt;
    &lt;/group&gt;
  &lt;/split&gt;
&lt;/dataSplitter&gt;
</code></pre>
<h2 id="a-namesec_1_3_3aoutput"><a name="sec_1_3_3"></a>Output</h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;records xmlns=&quot;records:2&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;records:2 file://records-v2.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;record&gt;
    &lt;data name=&quot;host&quot; value=&quot;192.168.1.100&quot; /&gt;
    &lt;data name=&quot;log&quot; value=&quot;-&quot; /&gt;
    &lt;data name=&quot;user&quot; value=&quot;-&quot; /&gt;
    &lt;data name=&quot;time&quot; value=&quot;12/Jul/2012:11:57:07 +0000&quot; /&gt;
    &lt;data name=&quot;url&quot; value=&quot;GET /doc.htm HTTP/1.1&quot;&gt;
      &lt;data name=&quot;httpMethod&quot; value=&quot;GET&quot; /&gt;
      &lt;data name=&quot;url&quot; value=&quot;/doc.htm&quot; /&gt;
      &lt;data name=&quot;protocol&quot; value=&quot;HTTP&quot; /&gt;
      &lt;data name=&quot;version&quot; value=&quot;1.1&quot; /&gt;
    &lt;/data&gt;
    &lt;data name=&quot;response&quot; value=&quot;200&quot; /&gt;
    &lt;data name=&quot;size&quot; value=&quot;4235&quot; /&gt;
    &lt;data name=&quot;referrer&quot; value=&quot;-&quot; /&gt;
    &lt;data name=&quot;userAgent&quot; value=&quot;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET4.0C; .NET4.0E; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)&quot; /&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data name=&quot;host&quot; value=&quot;192.168.1.100&quot; /&gt;
    &lt;data name=&quot;log&quot; value=&quot;-&quot; /&gt;
    &lt;data name=&quot;user&quot; value=&quot;-&quot; /&gt;
    &lt;data name=&quot;time&quot; value=&quot;12/Jul/2012:11:57:07 +0000&quot; /&gt;
    &lt;data name=&quot;url&quot; value=&quot;GET /default.css HTTP/1.1&quot;&gt;
      &lt;data name=&quot;httpMethod&quot; value=&quot;GET&quot; /&gt;
      &lt;data name=&quot;url&quot; value=&quot;/default.css&quot; /&gt;
      &lt;data name=&quot;protocol&quot; value=&quot;HTTP&quot; /&gt;
      &lt;data name=&quot;version&quot; value=&quot;1.1&quot; /&gt;
    &lt;/data&gt;
    &lt;data name=&quot;response&quot; value=&quot;200&quot; /&gt;
    &lt;data name=&quot;size&quot; value=&quot;3494&quot; /&gt;
    &lt;data name=&quot;referrer&quot; value=&quot;http://some.server:8080/doc.htm&quot; /&gt;
    &lt;data name=&quot;userAgent&quot; value=&quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; .NET CLR 1.1.4322; .NET CLR 2.0.50727; .NET4.0C; .NET4.0E; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729)&quot; /&gt;
  &lt;/record&gt;
&lt;/records&gt;
</code></pre>

</div>




    
	
  
    
    
	
    



<div class="td-content" style="--base-section-num: '4.'; page-break-before: always">
    
  <h1 id="pg-4e7eb119df912b5530510cddfbbe36eb">4 - Multi Line Example</h1>
    
	<p>Example multi line file where records are split over may lines. There are various ways this data could be treated but this example forms a record from data created when some fictitious query starts plus the subsequent query results.</p>
<h2 id="a-namesec_1_4_1ainput"><a name="sec_1_4_1"></a>Input</h2>
<pre><code class="language-text">09/07/2016    14:49:36    User = user1
09/07/2016    14:49:36    Query = some query

09/07/2016    16:34:40    Results:
09/07/2016    16:34:40    Line 1:   result1
09/07/2016    16:34:40    Line 2:   result2
09/07/2016    16:34:40    Line 3:   result3
09/07/2016    16:34:40    Line 4:   result4

09/07/2009    16:35:21    User = user2
09/07/2009    16:35:21    Query = some other query

09/07/2009    16:45:36    Results:
09/07/2009    16:45:36    Line 1:   result1
09/07/2009    16:45:36    Line 2:   result2
09/07/2009    16:45:36    Line 3:   result3
09/07/2009    16:45:36    Line 4:   result4
</code></pre>
<h2 id="a-namesec_1_4_2aconfiguration"><a name="sec_1_4_2"></a>Configuration</h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;

  &lt;!-- Match each record. We want to treat the query and results as a single event so match the two sets of data separated by a double new line --&gt;
  &lt;regex pattern=&quot;\n*((.*\n)+?\n(.*\n)+?\n)|\n*(.*\n?)+&quot;&gt;
    &lt;group&gt;

      &lt;!-- Split the record into query and results --&gt;
      &lt;regex pattern=&quot;(.*?)\n\n(.*)&quot; dotAll=&quot;true&quot;&gt;

        &lt;!-- Create a data element to output query data --&gt;
        &lt;data name=&quot;query&quot;&gt;
          &lt;group value=&quot;$1&quot;&gt;

            &lt;!-- We only want to output the date and time from the first line. --&gt;
            &lt;regex pattern=&quot;([^\t]*)\t([^\t]*)[\t]*([^=:]*)[=:]*(.*)&quot; maxMatch=&quot;1&quot;&gt;
              &lt;data name=&quot;date&quot; value=&quot;$1&quot; /&gt;
              &lt;data name=&quot;time&quot; value=&quot;$2&quot; /&gt;
              &lt;data name=&quot;$3&quot; value=&quot;$4&quot; /&gt;
            &lt;/regex&gt;
            
            &lt;!-- Output all other values --&gt;
            &lt;regex pattern=&quot;([^\t]*)\t([^\t]*)[\t]*([^=:]*)[=:]*(.*)&quot;&gt;
              &lt;data name=&quot;$3&quot; value=&quot;$4&quot; /&gt;
            &lt;/regex&gt;
          &lt;/group&gt;
        &lt;/data&gt;

        &lt;!-- Create a data element to output result data --&gt;
        &lt;data name=&quot;results&quot;&gt;
          &lt;group value=&quot;$2&quot;&gt;

            &lt;!-- We only want to output the date and time from the first line. --&gt;
            &lt;regex pattern=&quot;([^\t]*)\t([^\t]*)[\t]*([^=:]*)[=:]*(.*)&quot; maxMatch=&quot;1&quot;&gt;
              &lt;data name=&quot;date&quot; value=&quot;$1&quot; /&gt;
              &lt;data name=&quot;time&quot; value=&quot;$2&quot; /&gt;
              &lt;data name=&quot;$3&quot; value=&quot;$4&quot; /&gt;
            &lt;/regex&gt;
            
            &lt;!-- Output all other values --&gt;
            &lt;regex pattern=&quot;([^\t]*)\t([^\t]*)[\t]*([^=:]*)[=:]*(.*)&quot;&gt;
              &lt;data name=&quot;$3&quot; value=&quot;$4&quot; /&gt;
            &lt;/regex&gt;
          &lt;/group&gt;
        &lt;/data&gt;
      &lt;/regex&gt;
    &lt;/group&gt;
  &lt;/regex&gt;
&lt;/dataSplitter&gt;
</code></pre>
<h2 id="a-namesec_1_4_3aoutput"><a name="sec_1_4_3"></a>Output</h2>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;records xmlns=&quot;records:2&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;records:2 file://records-v2.0.xsd&quot; version=&quot;2.0&quot;&gt;
  &lt;record&gt;
    &lt;data name=&quot;query&quot;&gt;
      &lt;data name=&quot;date&quot; value=&quot;09/07/2016&quot; /&gt;
      &lt;data name=&quot;time&quot; value=&quot;14:49:36&quot; /&gt;
      &lt;data name=&quot;User&quot; value=&quot;user1&quot; /&gt;
      &lt;data name=&quot;Query&quot; value=&quot;some query&quot; /&gt;
    &lt;/data&gt;
    &lt;data name=&quot;results&quot;&gt;
      &lt;data name=&quot;date&quot; value=&quot;09/07/2016&quot; /&gt;
      &lt;data name=&quot;time&quot; value=&quot;16:34:40&quot; /&gt;
      &lt;data name=&quot;Results&quot; /&gt;
      &lt;data name=&quot;Line 1&quot; value=&quot;result1&quot; /&gt;
      &lt;data name=&quot;Line 2&quot; value=&quot;result2&quot; /&gt;
      &lt;data name=&quot;Line 3&quot; value=&quot;result3&quot; /&gt;
      &lt;data name=&quot;Line 4&quot; value=&quot;result4&quot; /&gt;
    &lt;/data&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data name=&quot;query&quot;&gt;
      &lt;data name=&quot;date&quot; value=&quot;09/07/2016&quot; /&gt;
      &lt;data name=&quot;time&quot; value=&quot;16:35:21&quot; /&gt;
      &lt;data name=&quot;User&quot; value=&quot;user2&quot; /&gt;
      &lt;data name=&quot;Query&quot; value=&quot;some other query&quot; /&gt;
    &lt;/data&gt;
    &lt;data name=&quot;results&quot;&gt;
      &lt;data name=&quot;date&quot; value=&quot;09/07/2016&quot; /&gt;
      &lt;data name=&quot;time&quot; value=&quot;16:45:36&quot; /&gt;
      &lt;data name=&quot;Results&quot; /&gt;
      &lt;data name=&quot;Line 1&quot; value=&quot;result1&quot; /&gt;
      &lt;data name=&quot;Line 2&quot; value=&quot;result2&quot; /&gt;
      &lt;data name=&quot;Line 3&quot; value=&quot;result3&quot; /&gt;
      &lt;data name=&quot;Line 4&quot; value=&quot;result4&quot; /&gt;
    &lt;/data&gt;
  &lt;/record&gt;
&lt;/records&gt;
</code></pre>

</div>




    
	
  
    
    
	
    



<div class="td-content" style="--base-section-num: '5.'; page-break-before: always">
    
  <h1 id="pg-8f4175cc7d3f7d584edb7958e8546094">5 - Element Reference</h1>
    
	<p>There are various elements used in a Data Splitter configuration to control behaviour. Each of these elements can be categorised as one of the following:</p>

</div>




    
      
  
  
  
  

  
  

  
    
    
	
    



<div class="td-content" style="--base-section-num: '5.1.'; ">
    
  <h1 id="pg-433f7e66c8f749c136edf8dd77485021">5.1 - Content Providers</h1>
    
	<p>Content providers take some content from the input source or elsewhere (see <a href="../../../../docs/user-guide/data-splitter/match-reference/3-3-use-of-fixed-strings/">fixed strings</a> and provide it to one or more expressions. Both the root element <code>&lt;dataSplitter&gt;</code> and <code>&lt;group&gt;</code> elements are content providers.</p>
<h2 id="a-namesec_2_1_1aroot-element-ltdatasplittergt"><a name="sec_2_1_1"></a>Root element &lt;dataSplitter&gt;</h2>
<p>The root element of a Data Splitter configuration is <code>&lt;dataSplitter&gt;</code>. It supplies content from the input source to one or more expressions defined within it. The way that content is buffered is controlled by the root element and the way that errors are handled as a result of child expressions not matching all of the content it supplies.</p>
<h3 id="a-namesec_2_1_1_1aattributes"><a name="sec_2_1_1_1"></a>Attributes</h3>
<p>The following attributes can be added to the <code>&lt;dataSplitter&gt;</code> root element:</p>
<ul>
<li><a href="#sec-2-1-1-1-1">ignoreErrors</a></li>
<li><a href="#sec-2-1-1-1-2">bufferSize</a></li>
</ul>
<h4 id="a-namesec-2-1-1-1-1aignoreerrors"><a name="sec-2-1-1-1-1"></a>ignoreErrors</h4>
<p>Data Splitter generates errors if not all of the content is matched by the regular expressions beneath the <code>&lt;dataSplitter&gt;</code> or within <code>&lt;group&gt;</code> elements. The error messages are intended to aid the user in writing good Data Splitter configurations. The intent is to indicate when the input data is not being matched fully and therefore possibly skipping some important data. Despite this, in some cases it is laborious to have to write expressions to match all content. In these cases it is preferable to add this attribute to ignore these errors. However it is often better to write expressions that capture all of the supplied content and discard unwanted characters. This attribute also affects errors generated by the use of the minMatch attribute on <code>&lt;regex&gt;</code> which is described later on.</p>
<p>Take the following example input:</p>
<pre><code class="language-text">Name1,Name2,Name3
value1,value2,value3 # a useless comment
value1,value2,value3 # a useless comment 
</code></pre>
<p>This could be matched with the following configuration:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;regex id=&quot;heading&quot; pattern=&quot;.+&quot; maxMatch=&quot;1&quot;&gt;
…
  &lt;/regex&gt;
  &lt;regex id=&quot;body&quot; pattern=&quot;\n[^#]+&quot;&gt;
…
  &lt;/regex&gt;
&lt;/dataSplitter&gt;
</code></pre>
<p>The above configuration would only match up to a comment for each record line, e.g.</p>
<pre><code class="language-text">Name1,Name2,Name3
value1,value2,value3 # a useless comment
value1,value2,value3 # a useless comment
</code></pre>
<p>This may well be the desired functionality but if there was useful content within the comment it would be lost. Because of this Data Splitter warns you when expressions are failing to match all of the content presented so that you can make sure that you aren’t missing anything important. In the above example it is obvious that this is the required behaviour but in more complex cases you might be otherwise unaware that your expressions were losing data.</p>
<p>To maintain this assurance that you are handling all content it is usually best to write expressions to explicitly match all content even though you may do nothing with some matches, e.g.</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;regex id=&quot;heading&quot; pattern=&quot;.+&quot; maxMatch=&quot;1&quot;&gt;
…
  &lt;/regex&gt;
  &lt;regex id=&quot;body&quot; pattern=&quot;\n([^#]+)#.+&quot;&gt;
…
  &lt;/regex&gt;
&lt;/dataSplitter&gt;
</code></pre>
<p>The above example would match all of the content and would therefore not generate warnings. Sub-expressions of &lsquo;body&rsquo; could use match group 1 and ignore the comment.</p>
<p>However as previously stated it might often be difficult to write expressions that will just match content that is to be discarded. In these cases ignoreErrors can be used to suppress errors caused by unmatched content.</p>
<h4 id="a-namesec-2-1-1-1-2abuffersize-advanced"><a name="sec-2-1-1-1-2"></a>bufferSize (Advanced)</h4>
<p>This is an optional attribute used to tune the size of the character buffer used by Data Splitter. The default size is 20000 characters and should be fine for most translations. The minimum value that this can be set to is 20000 characters and the maximum is 1000000000. The only reason to specify this attribute is when individual records are bigger than 10000 characters which is rarely the case.</p>
<h2 id="a-namesec_2_1_2agroup-element-ltgroupgt"><a name="sec_2_1_2"></a>Group element &lt;group&gt;</h2>
<p>Groups behave in a similar way to the root element in that they provide content for one or more inner expressions to deal with, e.g.</p>
<pre><code class="language-xml">&lt;group value=&quot;$1&quot;&gt;
  &lt;regex pattern=&quot;([^\t]*)\t([^\t]*)[\t]*([^=:]*)[=:]*(.*)&quot; maxMatch=&quot;1&quot;&gt;
  ...
  &lt;regex pattern=&quot;([^\t]*)\t([^\t]*)[\t]*([^=:]*)[=:]*(.*)&quot;&gt;
  ...
</code></pre>
<h3 id="a-namesec_2_1_2_1aattributes"><a name="sec_2_1_2_1"></a>Attributes</h3>
<p>As the <code>&lt;group&gt;</code> element is a content provider it also includes the same &lsquo;ignoreErrors&rsquo; attribute which behaves in the same way. The complete list of attributes for the <code>&lt;group&gt;</code> element is as follows:</p>
<ul>
<li><a href="#sec-2-1-2-1-1">id</a></li>
<li><a href="#sec-2-1-2-1-2">value</a></li>
<li><a href="#sec-2-1-2-1-3">ignoreErrors</a></li>
<li><a href="#sec-2-1-2-1-4">matchOrder</a></li>
<li><a href="#sec-2-1-2-1-5">reverse</a></li>
</ul>
<h4 id="a-namesec-2-1-2-1-1aid"><a name="sec-2-1-2-1-1"></a>id</h4>
<p>When Data Splitter reports errors it outputs an XPath to describe the part of the configuration that generated the error, e.g.</p>
<pre><code class="language-text">DSParser [2:1] ERROR: Expressions failed to match all of the content provided by group: regex[0]/group[0]/regex[3]/group[1] : &lt;group&gt;
</code></pre>
<p>It is often a little difficult to identify the configuration element that generated the error by looking at the path and the element description, particularly when multiple elements are the same, e.g. many <code>&lt;group&gt;</code> elements without attributes. To make identification easier you can add an &lsquo;id&rsquo; attribute to any element in the configuration resulting in error descriptions as follows:</p>
<pre><code class="language-text">DSParser [2:1] ERROR: Expressions failed to match all of the content provided by group: regex[0]/group[0]/regex[3]/group[1] : &lt;group id=&quot;myGroupId&quot;&gt;
</code></pre>
<h4 id="a-namesec-2-1-2-1-2avalue"><a name="sec-2-1-2-1-2"></a>value</h4>
<p>This attribute determines what content to present to child expressions. By default the entire content matched by a group’s parent expression is passed on by the group to child expressions. If required, content from a specific match group in the parent expression can be passed to child expressions using the value attribute, e.g. <code>value=&quot;$1&quot;</code>. In addition to this content can be composed in the same way as it is for data names and values. see <a href="../../../../docs/user-guide/data-splitter/match-reference/">match references</a> for a full description of match references.</p>
<h4 id="a-namesec-2-1-2-1-3aignoreerrors"><a name="sec-2-1-2-1-3"></a>ignoreErrors</h4>
<p>This behaves in the same way as for the root element.</p>
<h4 id="a-namesec-2-1-2-1-4amatchorder"><a name="sec-2-1-2-1-4"></a>matchOrder</h4>
<p>This is an optional attribute used to control how content is consumed by expression matches. Content can be consumed in sequence or in any order using <code>matchOrder=&quot;sequence&quot;</code> or <code>matchOrder=&quot;any&quot;</code>. If the attribute is not specified, Data Splitter will default to matching in sequence.</p>
<p>When matching in sequence, each match consumes some content and the content position is moved beyond the match ready for the subsequent match. However, in some cases the order of these constructs is not predictable, e.g. we may sometimes be presented with:</p>
<pre><code class="language-text">Value1=1 Value2=2
</code></pre>
<p>… or sometimes with:</p>
<pre><code class="language-text">Value2=2 Value1=1
</code></pre>
<p>Using a sequential match order the following example would work to find both values in <code>Value1=1 Value2=2</code></p>
<pre><code class="language-xml">&lt;group&gt;
  &lt;regex pattern=&quot;Value1=([^ ]*)&quot;&gt;
  ...
  &lt;regex pattern=&quot;Value2=([^ ]*)&quot;&gt;
  ...
</code></pre>
<p>… but this example would skip over Value2 and only find the value of Value1 if the input was <code>Value2=2 Value1=1</code>.</p>
<p>To be able to deal with content that contains these constructs in either order we need to change the match order to <code>any</code>.</p>
<p>When matching in any order, each match removes the matched section from the content rather than moving the position past the match so that all remaining content can be matched by subsequent expressions. In the following example the first expression would match and remove <code>Value1=1</code> from the supplied content and the second expression would be presented with <code> Value2=2</code> which it could also match.</p>
<pre><code class="language-xml">&lt;group matchOrder=&quot;any&quot;&gt;
  &lt;regex pattern=&quot;Value1=([^ ]*)&quot;&gt;
  ...
  &lt;regex pattern=&quot;Value2=([^ ]*)&quot;&gt;
  ...
</code></pre>
<p>If the attribute is omitted by default the match order will be sequential. This is the default behaviour as tokens are most often in sequence and consuming content in this way is more efficient as content does not need to be copied by the parser to chop out sections as is required for matching in any order. It is only necessary to use this feature when fields that are identifiable with a specific match can occur in any order.</p>
<h4 id="a-namesec-2-1-2-1-5areverse"><a name="sec-2-1-2-1-5"></a>reverse</h4>
<p>Occasionally it is desirable to reverse the content presented by a group to child expressions. This is because it is sometimes easier to form a pattern by matching content in reverse.</p>
<p>Take the following example content of name, value pairs delimited by <code>=</code> but with no spaces between names, multiple spaces between values and only a space between subsequent pairs:</p>
<pre><code class="language-text">ipAddress=123.123.123.123 zones=Zone 1, Zone 2, Zone 3 location=loc1 A user=An end user serverName=bigserver
</code></pre>
<p>We could write a pattern that matches each name value pair by matching up to the start of the next name, e.g.</p>
<pre><code class="language-xml">&lt;regex pattern=&quot;([^=]+)=(.+?)( [^=]+=)&quot;&gt;
</code></pre>
<p>This would match the following:</p>
<pre><code class="language-text">ipAddress=123.123.123.123 zones=
</code></pre>
<p>Here we are capturing the name and value for each pair in separate groups but the pattern has to also match the name from the next name value pair to find the end of the value. By default Data Splitter will move the content buffer to the end of the match ready for subsequent matches so the next name will not be available for matching.</p>
<p>In addition to matching too much content the above example also uses a reluctant qualifier <code>.+?</code>. Use of reluctant qualifiers almost always impacts performance so they are to be avoided if at all possible.</p>
<p>A better way to match the example content is to match the input in reverse, reading characters from right to left.</p>
<p>The following example demonstrates this:</p>
<pre><code class="language-xml">&lt;group reverse=&quot;true&quot;&gt;
  &lt;regex pattern=&quot;([^=]+)=([^ ]+)&quot;&gt;
    &lt;data name=&quot;$2&quot; value=&quot;$1&quot; /&gt;
  &lt;/regex&gt;
&lt;/group&gt;
</code></pre>
<p>Using the reverse attribute on the parent group causes content to be supplied to all child expressions in reverse order. In the above example this allows the pattern to match values followed by names which enables us to cope with the fact that values have multiple spaces but names have no spaces.</p>
<p>Content is only presented to child regular expressions in reverse. When referencing values from match groups the content is returned in the correct order, e.g. the above example would return:</p>
<pre><code class="language-xml">&lt;data name=&quot;ipAddress&quot; value=&quot;123.123.123.123&quot; /&gt;
&lt;data name=&quot;zones&quot; value=&quot;Zone 1, Zone 2, Zone 3&quot; /&gt;
&lt;data name=&quot;location&quot; value=&quot;loc1&quot; /&gt;
&lt;data name=&quot;user&quot; value=&quot;An end user&quot; /&gt;
&lt;data name=&quot;serverName&quot; value=&quot;bigserver&quot; /&gt;
</code></pre>
<p>The reverse feature isn&rsquo;t needed very often but there are a few cases where it really helps produce the desired output without the complexity and performance overhead of a reluctant match.</p>
<p>An alternative to using the reverse attribute is to use the original reluctant expression example but tell Data Splitter to make the subsequent name available for the next match by not advancing the content beyond the end of the previous value. This is done by using the <a href="../../../../docs/user-guide/data-splitter/element-reference/2-2-expressions/#sec-2-2-2-1-5">advance attribute</a> on the <code>&lt;regex&gt;</code>. However, the reverse attribute represents a better way to solve this particular problem and allows a simpler and more efficient regular expression to be used.</p>

</div>




    
	
  
    
    
	
    



<div class="td-content" style="--base-section-num: '5.2.'; page-break-before: always">
    
  <h1 id="pg-002b4e409b3795e26b4c2c408449ace2">5.2 - Expressions</h1>
    
	<p>Expressions match some data supplied by a parent content provider. The content matched by an expression depends on the type of expression and how it is configured.</p>
<p>The <code>&lt;split&gt;</code>, <code>&lt;regex&gt;</code> and <code>&lt;all&gt;</code> elements are all expressions and match content as described below.</p>
<h2 id="a-namesec_2_2_1athe-ltsplitgt-element"><a name="sec_2_2_1"></a>The &lt;split&gt; element</h2>
<p>The <code>&lt;split&gt;</code> element directs Data Splitter to break up content using a specified character sequence as a delimiter. In addition to this it is possible to specify characters that are used to escape the delimiter as well as characters that contain or &ldquo;quote&rdquo; a value that may include the delimiter sequence but allow it to be ignored.</p>
<h3 id="a-namesec_2_2_1_1aattributes"><a name="sec_2_2_1_1"></a>Attributes</h3>
<p>The <code>&lt;split&gt;</code> element has the following attributes:</p>
<ul>
<li><a href="#sec-2-2-1-1-1">id</a></li>
<li><a href="#sec-2-2-1-1-2">delimiter</a></li>
<li><a href="#sec-2-2-1-1-3">escape</a></li>
<li><a href="#sec-2-2-1-1-4">containerStart</a></li>
<li><a href="#sec-2-2-1-1-5">containerEnd</a></li>
<li><a href="#sec-2-2-1-1-6">maxMatch</a></li>
<li><a href="#sec-2-2-1-1-7">minMatch</a></li>
<li><a href="#sec-2-2-1-1-8">onlyMatch</a></li>
</ul>
<h4 id="a-namesec-2-2-1-1-1aid"><a name="sec-2-2-1-1-1"></a>id</h4>
<p>Optional attribute used to debug the location of expressions causing errors, see <a href="../../../../docs/user-guide/data-splitter/element-reference/2-1-content-providers/#sec-2-1-2-1-1">id</a>.</p>
<h4 id="a-namesec-2-2-1-1-2adelimiter"><a name="sec-2-2-1-1-2"></a>delimiter</h4>
<p>A required attribute used to specify the character string that will be used as a delimiter to split the supplied content unless it is preceded by an escape character or within a container if specified. Several of the previous examples use this attribute.</p>
<h4 id="a-namesec-2-2-1-1-3aescape"><a name="sec-2-2-1-1-3"></a>escape</h4>
<p>An optional attribute used to specify a character sequence that is used to escape the delimiter. Many delimited text formats have an escape character that is used to tell any parser that the following delimiter should be ignored, e.g. often a character such as &lsquo;' is used to escape the character that follows it so that it is not treated as a delimiter. When specified this escape sequence also applies to any container characters that may be specified.</p>
<h4 id="a-namesec-2-2-1-1-4acontainerstart"><a name="sec-2-2-1-1-4"></a>containerStart</h4>
<p>An optional attribute used to specify a character sequence that will make this expression ignore the presence of delimiters until an end container is found. If the character is preceded by the specified escape sequence then this container sequence will be ignored and the expression will continue matching characters up to a delimiter.</p>
<p>If used <code>containerEnd</code> must also be specified. If the container characters are to be ignored from the match then match group 1 must be used instead of 0.</p>
<h4 id="a-namesec-2-2-1-1-5acontainerend"><a name="sec-2-2-1-1-5"></a>containerEnd</h4>
<p>An optional attribute used to specify a character sequence that will make this expression stop ignoring the presence of delimiters if it believes it is currently in a container. If the character is preceded by the specified escape sequence then this container sequence will be ignored and the expression will continue matching characters while ignoring the presence of any delimiter.</p>
<p>If used <code>containerStart</code> must also be specified. If the container characters are to be ignored from the match then match group 1 must be used instead of 0.</p>
<h4 id="a-namesec-2-2-1-1-6amaxmatch"><a name="sec-2-2-1-1-6"></a>maxMatch</h4>
<p>An optional attribute used to specify the maximum number of times this expression is allowed to match the supplied content. If you do not supply this attribute then the Data Splitter will keep matching the supplied content until it reaches the end. If specified Data Splitter will stop matching the supplied content when it has matched it the specified number of times.</p>
<p>This attribute is used in the <a href="../../../../docs/user-guide/data-splitter/1-2-simple-csv-example-with-heading/">&lsquo;CSV with header line&rsquo;</a> example to ensure that only the first line is treated as a header line.</p>
<h4 id="a-namesec-2-2-1-1-7aminmatch"><a name="sec-2-2-1-1-7"></a>minMatch</h4>
<p>An optional attribute used to specify the minimum number of times this expression should match the supplied content. If you do not supply this attribute then Data Splitter will not enforce that the expression matches the supplied content. If specified Data Splitter will generate an error if the expression does not match the supplied content at least as many times as specified.</p>
<p>Unlike <code>maxMatch</code>, <code>minMatch</code> does not control the matching process but instead controls the production of error messages generated if the parser is not seeing the expected input.</p>
<h4 id="a-namesec-2-2-1-1-8aonlymatch"><a name="sec-2-2-1-1-8"></a>onlyMatch</h4>
<p>Optional attribute to use this expression only for specific instances of a match of the parent expression, e.g. on the 4th, 5th and 8th matches of the parent expression specified by &lsquo;4,5,8&rsquo;. This is used when this expression should only be used to subdivide content from certain parent matches.</p>
<h2 id="a-namesec_2_2_2athe-ltregexgt-element"><a name="sec_2_2_2"></a>The &lt;regex&gt; element</h2>
<p>The <code>&lt;regex&gt;</code> element directs Data Splitter to match content using the specified regular expression pattern. In addition to this the same match control attributes that are available on the <code>&lt;split&gt;</code> element are also present as well as attributes to alter the way the pattern works.</p>
<h3 id="a-namesec_2_2_2_1aattributes"><a name="sec_2_2_2_1"></a>Attributes</h3>
<p>The <code>&lt;regex&gt;</code> element has the following attributes:</p>
<ul>
<li><a href="#sec-2-2-2-1-1">id</a></li>
<li><a href="#sec-2-2-2-1-2">pattern</a></li>
<li><a href="#sec-2-2-2-1-3">dotAll</a></li>
<li><a href="#sec-2-2-2-1-4">caseInsensitive</a></li>
<li><a href="#sec-2-2-2-1-5">maxMatch</a></li>
<li><a href="#sec-2-2-2-1-6">minMatch</a></li>
<li><a href="#sec-2-2-2-1-7">onlyMatch</a></li>
<li><a href="#sec-2-2-2-1-8">advance</a></li>
</ul>
<h4 id="a-namesec-2-2-2-1-1aid"><a name="sec-2-2-2-1-1"></a>id</h4>
<p>Optional attribute used to debug the location of expressions causing errors, see <a href="../../../../docs/user-guide/data-splitter/element-reference/2-1-content-providers/#sec-2-1-2-1-1">id</a>.</p>
<h4 id="a-namesec-2-2-2-1-2apattern"><a name="sec-2-2-2-1-2"></a>pattern</h4>
<p>This is a required attribute used to specify a regular expression to use to match on the supplied content. The pattern is used to match the content multiple times until the end of the content is reached while the maxMatch and onlyMatch conditions are satisfied.</p>
<h4 id="a-namesec-2-2-2-1-3adotall"><a name="sec-2-2-2-1-3"></a>dotAll</h4>
<p>An optional attribute used to specify if the use of &lsquo;.&rsquo; in the supplied pattern matches all characters including new lines. If &rsquo;true&rsquo; &lsquo;.&rsquo; will match all characters including new lines, if &lsquo;false&rsquo; it will only match up to a new line. If this attribute is not specified it defaults to &lsquo;false&rsquo; and will only match up to a new line.</p>
<p>This attribute is used in many of the multiline examples above.</p>
<h4 id="a-namesec-2-2-2-1-4acaseinsensitive"><a name="sec-2-2-2-1-4"></a>caseInsensitive</h4>
<p>An optional attribute used to specify if the supplied pattern should match content in a case insensitive way. If &rsquo;true&rsquo; the expression will match content in a case insensitive manner, if &lsquo;false&rsquo; it will match the content in a case sensitive manner. If this attribute is not specified it defaults to &lsquo;false&rsquo; and will match the content in a case sensitive manner.</p>
<h4 id="a-namesec-2-2-2-1-5amaxmatch"><a name="sec-2-2-2-1-5"></a>maxMatch</h4>
<p>This is used in the same way it is on the <code>&lt;split&gt;</code> element, see <a href="#sec-2-2-1-1-6">maxMatch</a>.</p>
<h4 id="a-namesec-2-2-2-1-6aminmatch"><a name="sec-2-2-2-1-6"></a>minMatch</h4>
<p>This is used in the same way it is on the <code>&lt;split&gt;</code> element, see <a href="#sec-2-2-1-1-7">minMatch</a>.</p>
<h4 id="a-namesec-2-2-2-1-7aonlymatch"><a name="sec-2-2-2-1-7"></a>onlyMatch</h4>
<p>This is used in the same way it is on the <code>&lt;split&gt;</code> element, see <a href="#sec-2-2-1-1-8">onlyMatch</a>.</p>
<h4 id="a-namesec-2-2-2-1-8aadvance"><a name="sec-2-2-2-1-8"></a>advance</h4>
<p>After an expression has matched content in the buffer, the buffer start position is advanced so that it moves to the end of the entire match. This means that subsequent expressions operating on the content buffer will not see the previously matched content again. This is normally required behaviour, but in some cases some of the content from a match is still required for subsequent matches. Take the following example of name value pairs:</p>
<pre><code class="language-text">name1=some value 1 name2=some value 2 name3=some value 3
</code></pre>
<p>The first name value pair could be matched with the following expression:</p>
<pre><code class="language-xml">&lt;regex pattern=&quot;([^=]+)=(.+?) [^= ]+=&quot;&gt;
</code></pre>
<p>The above expression would match as follows:</p>
<pre><code class="language-text">name1=some value 1 name2=some value 2 name3=some value 3
</code></pre>
<p>In this example we have had to do a reluctant match to extract the value in group 2 and not include the subsequent name. Because the reluctant match requires us to specify what we are reluctantly matching up to, we have had to include an expression after it that matches the next name.</p>
<p>By default the parser will move the character buffer to the end of the entire match so the next expression will be presented with the following:</p>
<pre><code class="language-text">some value 2 name3=some value 3
</code></pre>
<p>Therefore <code>name2</code> will have been lost from the content buffer and will not be available for matching.</p>
<p>This behaviour can be altered by telling the expression how far to advance the character buffer after matching. This is done with the advance attribute and is used to specify the match group whose end position should be treated as the point the content buffer should advance to, e.g.</p>
<pre><code class="language-xml">&lt;regex pattern=&quot;([^=]+)=(.+?) [^= ]+=&quot; advance=&quot;2&quot;&gt;
</code></pre>
<p>In this example the content buffer will only advance to the end of match group 2 and subsequent expressions will be presented with the following content:</p>
<pre><code class="language-text">name2=some value 2 name3=some value 3
</code></pre>
<p>Therefore <code>name2</code> will still be available in the content buffer.</p>
<p>It is likely that the advance feature will only be useful in cases where a reluctant match is performed. Reluctant matches are discouraged for performance reasons so this feature should rarely be used. A better way to tackle the above example would be to present the content in <a href="../../../../docs/user-guide/data-splitter/element-reference/2-1-content-providers/#sec-2-1-2-1-5">reverse</a>, however this is only possible if the expression is within a group, i.e. is not a root expression. There may also be more complex cases where reversal is not an option and the use of a reluctant match is the only option.</p>
<h2 id="a-namesec_2_2_3athe-ltallgt-element"><a name="sec_2_2_3"></a>The &lt;all&gt; element</h2>
<p>The <code>&lt;all&gt;</code> element matches the entire content of the parent group and makes it available to child groups or <code>&lt;data&gt;</code> elements. The purpose of <code>&lt;all&gt;</code> is to act as a catch all expression to deal with content that is not handled by a more specific expression, e.g. to output some other unknown, unrecognised or unexpected data.</p>
<pre><code class="language-xml">&lt;group&gt;
  &lt;regex pattern=&quot;^\s*([^=]+)=([^=]+)\s*&quot;&gt;
    &lt;data name=&quot;$1&quot; value=&quot;$2&quot; /&gt;
  &lt;/regex&gt;

  &lt;!-- Output unexpected data --&gt;
  &lt;all&gt;
    &lt;data name=&quot;unknown&quot; value=&quot;$&quot; /&gt;
  &lt;/all&gt;
&lt;/group&gt;
</code></pre>
<p>The <code>&lt;all&gt;</code> element provides the same functionality as using <code>.*</code> as a pattern in a <code>&lt;regex&gt;</code> element and where dotAll is set to true, e.g. <code>&lt;regex pattern=&quot;.*&quot; dotAll=&quot;true&quot;&gt;</code>. However it performs much faster as it doesn’t require pattern matching logic and is therefore always preferred.</p>
<h3 id="a-namesec_2_2_3_1aattributes"><a name="sec_2_2_3_1"></a>Attributes</h3>
<p>The <code>&lt;all&gt;</code> element has the following attributes:</p>
<ul>
<li><a href="#sec-2-2-3-1-1">id</a></li>
</ul>
<h4 id="a-namesec-2-2-3-1-1aid"><a name="sec-2-2-3-1-1"></a>id</h4>
<p>Optional attribute used to debug the location of expressions causing errors, see <a href="../../../../docs/user-guide/data-splitter/element-reference/2-1-content-providers/#sec-2-1-2-1-1">id</a>.</p>

</div>




    
	
  
    
    
	
    



<div class="td-content" style="--base-section-num: '5.3.'; page-break-before: always">
    
  <h1 id="pg-7a65167c519705ee561f6d7d28e6dd8a">5.3 - Output</h1>
    
	<p>As with all other aspects of Data Splitter, output XML is determined by adding certain elements to the Data Splitter configuration.</p>
<h2 id="a-namesec_2_4_1athe-ltdatagt-element"><a name="sec_2_4_1"></a>The &lt;data&gt; element</h2>
<p>Output is created by Data Splitter using one or more <code>&lt;data&gt;</code> elements in the configuration. The first <code>&lt;data&gt;</code> element that is encountered within a matched expression will result in parent <code>&lt;record&gt;</code> elements being produced in the output.</p>
<h3 id="a-namesec_2_4_1_1aattributes"><a name="sec_2_4_1_1"></a>Attributes</h3>
<p>The <code>&lt;data&gt;</code> element has the following attributes:</p>
<ul>
<li><a href="#sec-2-4-1-1-1">id</a></li>
<li><a href="#sec-2-4-1-1-2">name</a></li>
<li><a href="#sec-2-4-1-1-3">value</a></li>
</ul>
<h4 id="a-namesec-2-4-1-1-1aid"><a name="sec-2-4-1-1-1"></a>id</h4>
<p>Optional attribute used to debug the location of expressions causing errors, see <a href="../../../../docs/user-guide/data-splitter/element-reference/2-1-content-providers/#sec-2-1-2-1-1">id</a>.</p>
<h4 id="a-namesec-2-4-1-1-2aname"><a name="sec-2-4-1-1-2"></a>name</h4>
<p>Both the name and value attributes of the <code>&lt;data&gt;</code> element can be specified using <a href="../../../../docs/user-guide/data-splitter/match-reference/">match references</a>.</p>
<h4 id="a-namesec-2-4-1-1-3avalue"><a name="sec-2-4-1-1-3"></a>value</h4>
<p>Both the name and value attributes of the <code>&lt;data&gt;</code> element can be specified using <a href="../../../../docs/user-guide/data-splitter/match-reference/">match references</a>.</p>
<h4 id="a-namesec_2_4_1_2asingle-ltdatagt-element-example"><a name="sec_2_4_1_2"></a>Single &lt;data&gt; element example</h4>
<p>The simplest example that can be provided uses a single <code>&lt;data&gt;</code> element within a <code>&lt;split&gt;</code> expression.</p>
<p>Given the following input:</p>
<pre><code class="language-text">This is line 1
This is line 2
This is line 3
</code></pre>
<p>… and the following configuration:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;split delimiter=&quot;\n&quot; &gt;
    &lt;data value=&quot;$1&quot;/&gt;
  &lt;/split&gt;
&lt;/dataSplitter&gt;
</code></pre>
<p>… you would get the following output:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;records xmlns=&quot;records:2&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;records:2 file://records-v2.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;record&gt;
    &lt;data value=&quot;This is line 1&quot; /&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data value=&quot;This is line 2&quot; /&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data value=&quot;This is line 3&quot; /&gt;
  &lt;/record&gt;
&lt;/records&gt;
</code></pre>
<h4 id="a-namesec_2_4_1_3amultiple-ltdatagt-element-example"><a name="sec_2_4_1_3"></a>Multiple &lt;data&gt; element example</h4>
<p>You could also output multiple <code>&lt;data&gt;</code> elements for the same <code>&lt;record&gt;</code> by adding multiple elements within the same expression:</p>
<p>Given the following input:</p>
<pre><code class="language-text">ip=1.1.1.1 user=user1
ip=2.2.2.2 user=user2
ip=3.3.3.3 user=user3
</code></pre>
<p>… and the following configuration:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;regex pattern=&quot;ip=([^ ]+) user=([^ ]+)\s*&quot;&gt;
    &lt;data name=&quot;ip&quot; value=&quot;$1&quot;/&gt;
    &lt;data name=&quot;user&quot; value=&quot;$2&quot;/&gt;
  &lt;/split&gt;
&lt;/dataSplitter&gt;
</code></pre>
<p>… you would get the following output:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;records xmlns=&quot;records:2&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;records:2 file://records-v2.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;record&gt;
    &lt;data name=&quot;ip&quot; value=&quot;1.1.1.1&quot; /&gt;
    &lt;data name=&quot;user&quot; value=&quot;user1&quot; /&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data name=&quot;ip&quot; value=&quot;2.2.2.2&quot; /&gt;
    &lt;data name=&quot;user&quot; value=&quot;user2&quot; /&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data name=&quot;ip&quot; value=&quot;3.3.3.3&quot; /&gt;
    &lt;data name=&quot;user&quot; value=&quot;user3&quot; /&gt;
  &lt;/record&gt;
&lt;/records&gt;
</code></pre>
<h3 id="a-namesec_2_4_1_4amulti-level-ltdatagt-elements"><a name="sec_2_4_1_4"></a>Multi level &lt;data&gt; elements</h3>
<p>As long as all data elements occur within the same parent/ancestor expression, all data elements will be output within the same record.</p>
<p>Given the following input:</p>
<pre><code class="language-text">ip=1.1.1.1 user=user1
ip=2.2.2.2 user=user2
ip=3.3.3.3 user=user3
</code></pre>
<p>… and the following configuration:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;split delimiter=&quot;\n&quot; &gt;
    &lt;data name=&quot;line&quot; value=&quot;$1&quot;/&gt;

    &lt;group value=&quot;$1&quot;&gt;
      &lt;regex pattern=&quot;ip=([^ ]+) user=([^ ]+)&quot;&gt;
        &lt;data name=&quot;ip&quot; value=&quot;$1&quot;/&gt;
        &lt;data name=&quot;user&quot; value=&quot;$2&quot;/&gt;
      &lt;/regex&gt;
    &lt;/group&gt;
  &lt;/split&gt;
&lt;/dataSplitter&gt;
</code></pre>
<p>… you would get the following output:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;records xmlns=&quot;records:2&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;records:2 file://records-v2.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;record&gt;
    &lt;data name=&quot;line&quot; value=&quot;ip=1.1.1.1 user=user1&quot; /&gt;
    &lt;data name=&quot;ip&quot; value=&quot;1.1.1.1&quot; /&gt;
    &lt;data name=&quot;user&quot; value=&quot;user1&quot; /&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data name=&quot;line&quot; value=&quot;ip=2.2.2.2 user=user2&quot; /&gt;
    &lt;data name=&quot;ip&quot; value=&quot;2.2.2.2&quot; /&gt;
    &lt;data name=&quot;user&quot; value=&quot;user2&quot; /&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data name=&quot;line&quot; value=&quot;ip=3.3.3.3 user=user3&quot; /&gt;
    &lt;data name=&quot;ip&quot; value=&quot;3.3.3.3&quot; /&gt;
    &lt;data name=&quot;user&quot; value=&quot;user3&quot; /&gt;
  &lt;/record&gt;
&lt;/records&gt;
</code></pre>
<h3 id="a-namesec_2_4_1_5anesting-ltdatagt-elements"><a name="sec_2_4_1_5"></a>Nesting &lt;data&gt; elements</h3>
<p>Rather than having <code>&lt;data&gt;</code> elements all appear as children of <code>&lt;record&gt;</code> it is possible to nest them either as direct children or within child groups.</p>
<h4 id="a-namesec-2-4-1-5-1adirect-children"><a name="sec-2-4-1-5-1"></a>Direct children</h4>
<p>Given the following input:</p>
<pre><code class="language-text">ip=1.1.1.1 user=user1
ip=2.2.2.2 user=user2
ip=3.3.3.3 user=user3
</code></pre>
<p>… and the following configuration:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;regex pattern=&quot;ip=([^ ]+) user=([^ ]+)\s*&quot;&gt;
    &lt;data name=&quot;line&quot; value=&quot;$&quot;&gt;
      &lt;data name=&quot;ip&quot; value=&quot;$1&quot;/&gt;
      &lt;data name=&quot;user&quot; value=&quot;$2&quot;/&gt;
    &lt;/data&gt;
  &lt;/split&gt;
&lt;/dataSplitter&gt;
</code></pre>
<p>… you would get the following output:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;records xmlns=&quot;records:2&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;records:2 file://records-v2.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;record&gt;
    &lt;data name=&quot;line&quot; value=&quot;ip=1.1.1.1 user=user1&quot;&gt;
      &lt;data name=&quot;ip&quot; value=&quot;1.1.1.1&quot; /&gt;
      &lt;data name=&quot;user&quot; value=&quot;user1&quot; /&gt;
    &lt;/data&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data name=&quot;line&quot; value=&quot;ip=2.2.2.2 user=user2&quot;&gt;
      &lt;data name=&quot;ip&quot; value=&quot;2.2.2.2&quot; /&gt;
      &lt;data name=&quot;user&quot; value=&quot;user2&quot; /&gt;
    &lt;/data&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data name=&quot;line&quot; value=&quot;ip=3.3.3.3 user=user3&quot;&gt;
      &lt;data name=&quot;ip&quot; value=&quot;3.3.3.3&quot; /&gt;
      &lt;data name=&quot;user&quot; value=&quot;user3&quot; /&gt;
    &lt;/data&gt;
  &lt;/record&gt;
&lt;/records&gt;
</code></pre>
<h4 id="a-namesec-2-4-1-5-2awithin-child-groups"><a name="sec-2-4-1-5-2"></a>Within child groups</h4>
<p>Given the following input:</p>
<pre><code class="language-text">ip=1.1.1.1 user=user1
ip=2.2.2.2 user=user2
ip=3.3.3.3 user=user3
</code></pre>
<p>… and the following configuration:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;split delimiter=&quot;\n&quot; &gt;
    &lt;data name=&quot;line&quot; value=&quot;$1&quot;&gt;
      &lt;group value=&quot;$1&quot;&gt;
        &lt;regex pattern=&quot;ip=([^ ]+) user=([^ ]+)&quot;&gt;
          &lt;data name=&quot;ip&quot; value=&quot;$1&quot;/&gt;
          &lt;data name=&quot;user&quot; value=&quot;$2&quot;/&gt;
        &lt;/regex&gt;
      &lt;/group&gt;
    &lt;/data&gt;
  &lt;/split&gt;
&lt;/dataSplitter&gt;
</code></pre>
<p>… you would get the following output:</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;records xmlns=&quot;records:2&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;records:2 file://records-v2.0.xsd&quot; version=&quot;3.0&quot;&gt;
  &lt;record&gt;
    &lt;data name=&quot;line&quot; value=&quot;ip=1.1.1.1 user=user1&quot;&gt;
      &lt;data name=&quot;ip&quot; value=&quot;1.1.1.1&quot; /&gt;
      &lt;data name=&quot;user&quot; value=&quot;user1&quot; /&gt;
    &lt;/data&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data name=&quot;line&quot; value=&quot;ip=2.2.2.2 user=user2&quot;&gt;
      &lt;data name=&quot;ip&quot; value=&quot;2.2.2.2&quot; /&gt;
      &lt;data name=&quot;user&quot; value=&quot;user2&quot; /&gt;
    &lt;/data&gt;
  &lt;/record&gt;
  &lt;record&gt;
    &lt;data name=&quot;line&quot; value=&quot;ip=3.3.3.3 user=user3&quot;&gt;
      &lt;data name=&quot;ip&quot; value=&quot;3.3.3.3&quot; /&gt;
      &lt;data name=&quot;user&quot; value=&quot;user3&quot; /&gt;
    &lt;/data&gt;
  &lt;/record&gt;
&lt;/records&gt;
</code></pre>
<p>The above example produces the same output as the previous but could be used to apply much more complex expression logic to produce the child <code>&lt;data&gt;</code> elements, e.g. the inclusion of multiple child expressions to deal with different types of lines.</p>

</div>




    
	
  
    
    
	
    



<div class="td-content" style="--base-section-num: '5.4.'; page-break-before: always">
    
  <h1 id="pg-51f3f0c126598dfdbe243f6ba10324b0">5.4 - Variables</h1>
    
	<p>A variable is added to Data Splitter using the <code>&lt;var&gt;</code> element. A variable is used to store matches from a parent expression for use in a reference elsewhere in the configuration, see <a href="../../../../docs/user-guide/data-splitter/match-reference/3-2-variable-reference/#variable-reference">variable reference</a>.</p>
<p>The most recent matches are stored for use in local references, i.e. references that are in the same match scope as the variable. Multiple matches are stored for use in references that are in a separate match scope. The concept of different variable scopes is described in <a href="../../../../docs/user-guide/data-splitter/match-reference/3-2-variable-reference/#sec-3-2-2">scopes</a>.</p>
<h2 id="a-namesec-2-3-1athe-ltvargt-element"><a name="sec-2-3-1"></a>The &lt;var&gt; element</h2>
<p>The <code>&lt;var&gt;</code> element is used to tell Data Splitter to store matches from a parent expression for use in a reference.</p>
<h3 id="a-namesec-2-3-1-1aattributes"><a name="sec-2-3-1-1"></a>Attributes</h3>
<p>The <code>&lt;var&gt;</code> element has the following attributes:</p>
<ul>
<li><a href="#sec-2-3-1-1-1">id</a></li>
</ul>
<h4 id="a-namesec-2-3-1-1-1aid"><a name="sec-2-3-1-1-1"></a>id</h4>
<p>Mandatory attribute used to uniquely identify it within the configuration (see <a href="../../../../docs/user-guide/data-splitter/element-reference/2-1-content-providers/#sec-2-1-2-1-1">id</a>) and is the means by which a variable is referenced, e.g. <code>$VAR_ID$</code>.</p>

</div>




    
	
  

    
	
  
    
    
	
    



<div class="td-content" style="--base-section-num: '6.'; page-break-before: always">
    
  <h1 id="pg-aaf101b97e91090cfb3df1bcf42a141a">6 - Match References, Variables and Fixed Strings</h1>
    
	<p>The <code>&lt;group&gt;</code> and <code>&lt;data&gt;</code> elements can reference match groups from parent expressions or from stored matches in variables. In the case of the <code>&lt;group&gt;</code> element, referenced values are passed on to child expressions whereas the <code>&lt;data&gt;</code> element can use match group references for name and value attributes. In the case of both elements the way of specifying references is the same.</p>

</div>




    
      
  
  
  
  

  
  

  
    
    
	
    



<div class="td-content" style="--base-section-num: '6.1.'; page-break-before: always">
    
  <h1 id="pg-3b82e13ffa085113005df16df1cec517">6.1 - Concatenation of references</h1>
    
	<p>It is possible to concatenate multiple fixed strings and match group references using the <code>+</code> character. As with all references and fixed strings this can be done in <code>&lt;group&gt;</code> value and <code>&lt;data&gt;</code> name and value attributes. However concatenation does have some performance overhead as new buffers have to be created to store concatenated content.</p>
<p>A good example of concatenation is the production of ISO8601 date format from data in the previous example:</p>
<pre><code class="language-csv">01/01/2010,00:00:00
</code></pre>
<p>Here the following <code>&lt;regex&gt;</code> could be used to extract the relevant date, time groups:</p>
<pre><code class="language-xml">&lt;regex pattern=&quot;(\d{2})/(\d{2})/(\d{4}),(\d{2}):(\d{2}):(\d{2})&quot;&gt;
</code></pre>
<p>The match groups from this expression can be concatenated with the following value output pattern in the data element:</p>
<pre><code class="language-xml">&lt;data name=&quot;dateTime&quot; value=&quot;$3+’-‘+$2+’-‘+$1+’-‘+’T’+$4+’:’+$5+’:’+$6+’.000Z’&quot; /&gt;
</code></pre>
<p>Using the original example, this would result in the output:</p>
<pre><code class="language-xml">&lt;data name=&quot;dateTime&quot; value=&quot;2010-01-01T00:00:00.000Z&quot; /&gt;
</code></pre>
<p>Note that the value output pattern wraps all fixed strings in single quotes. This is necessary when concatenating strings and references so that Data Splitter can determine which parts are to be treated as fixed strings. This also allows fixed strings to contain <code>$</code> and <code>+</code> characters.</p>
<p>As single quotes are used for this purpose, a single quote needs to be escaped with another single quote if one is desired in a fixed string, e.g.</p>
<pre><code class="language-text">‘this ‘’is quoted text’’’
</code></pre>
<p>will result in:</p>
<pre><code class="language-text">this ‘is quoted text’
</code></pre>

</div>




    
	
  
    
    
	
    



<div class="td-content" style="--base-section-num: '6.2.'; page-break-before: always">
    
  <h1 id="pg-1634da39a3ac0fbcef0aa75957192611">6.2 - Expression match references</h1>
    
	<p>Referencing matches in expressions is done using <code>$</code>. In addition to this a match group number may be added to just retrieve part of the expression match. The applicability and effect that this has depends on the type of expression used.</p>
<h2 id="a-namesec-3-1-1areferences-to-ltsplitgt-match-groups"><a name="sec-3-1-1"></a>References to &lt;split&gt; Match Groups</h2>
<p>In the following example a line matched by a parent <code>&lt;split&gt;</code> expression is referenced by a child <code>&lt;data&gt;</code> element.</p>
<pre><code class="language-xml">&lt;split delimiter=&quot;\n&quot; &gt;
  &lt;data name=&quot;line&quot; value=&quot;$&quot;/&gt;
&lt;/split&gt;
</code></pre>
<p>A <code>&lt;split&gt;</code> element matches content up to and including the specified <a href="../../../../docs/user-guide/data-splitter/element-reference/2-2-expressions/#sec-2-2-1-1-2">delimiter</a>, so the above reference would output the entire line plus the delimiter. However there are various match groups that can be used by child <code>&lt;group&gt;</code> and <code>&lt;data&gt;</code> elements to reference sections of the matched content.</p>
<p>To illustrate the content provided by each match group, take the following example:</p>
<pre><code class="language-text">&quot;This is some text\, that we wish to match&quot;, &quot;This is the next text&quot;
</code></pre>
<p>And the following <code>&lt;split&gt;</code> element:</p>
<pre><code class="language-xml">&lt;split delimiter=&quot;,&quot; escape=&quot;\&quot;&gt;
</code></pre>
<p>The match groups are as follows:</p>
<ul>
<li>$ or $0: The entire content that is matched including the specified delimiter at the end</li>
</ul>
<p><code>&quot;This is some text\, that we wish to match&quot;,</code></p>
<ul>
<li>$1: The content up to the specified delimiter at the end</li>
</ul>
<p><code>&quot;This is some text\, that we wish to match&quot;</code></p>
<ul>
<li>$2: The content up to the specified delimiter at the end and filtered to remove escape characters (more expensive than $1)</li>
</ul>
<p><code>&quot;This is some text, that we wish to match&quot;</code></p>
<p>In addition to this behaviour match groups 1 and 2 will omit outermost whitespace and container characters if specified, e.g. with the following content:</p>
<pre><code class="language-text">&quot;  This is some text\, that we wish to match  &quot;  , &quot;This is the next text&quot;
</code></pre>
<p>And the following <code>&lt;split&gt;</code> element:</p>
<pre><code class="language-xml">&lt;split delimiter=&quot;,&quot; escape=&quot;\&quot; containerStart=&quot;&amp;quot&quot; containerEnd=&quot;&amp;quot&quot;&gt;
</code></pre>
<p>The match groups are as follows:</p>
<ul>
<li>$ or $0: The entire content that is matched including the specified delimiter at the end</li>
</ul>
<p><code>&quot;  This is some text\, that we wish to match  &quot;  ,</code></p>
<ul>
<li>$1: The content up to the specified delimiter at the end and strips outer containers.</li>
</ul>
<p><code>This is some text\, that we wish to match</code></p>
<ul>
<li>$2: The content up to the specified delimiter at the end and strips outer containers and filtered to remove escape characters (more computationally expensive than $1)</li>
</ul>
<p><code>This is some text, that we wish to match</code></p>
<h2 id="a-namesec_3_1_2areferences-to-ltregexgt-match-groups"><a name="sec_3_1_2"></a>References to &lt;regex&gt; Match Groups</h2>
<p>Like the <code>&lt;split&gt;</code> element various match groups can be referenced in a <code>&lt;regex&gt;</code> expression to retrieve portions of matched content. This content can be used as values for <code>&lt;group&gt;</code> and <code>&lt;data&gt;</code> elements.</p>
<p>Given the following input:</p>
<pre><code class="language-text">ip=1.1.1.1 user=user1
</code></pre>
<p>And the following <code>&lt;regex&gt;</code> element:</p>
<pre><code class="language-xml">&lt;regex pattern=&quot;ip=([^ ]+) user=([^ ]+)&quot;&gt;
</code></pre>
<p>The match groups are as follows:</p>
<ul>
<li>$ or $0: The entire content that is matched by the expression</li>
</ul>
<p><code>ip=1.1.1.1 user=user1</code></p>
<ul>
<li>$1: The content of the first match group</li>
</ul>
<p><code>1.1.1.1</code></p>
<ul>
<li>$2: The content of the second match group</li>
</ul>
<p><code>user1</code></p>
<p>Match group numbers in regular expressions are determined by the order that their open bracket appears in the expression.</p>
<h2 id="a-namesec_3_1_3areferences-to-ltanygt-match-groups"><a name="sec_3_1_3"></a>References to &lt;any&gt; Match Groups</h2>
<p>The <code>&lt;any&gt;</code> element does not have any match groups and always returns the entire content that was passed to it when referenced with $.</p>

</div>




    
	
  
    
    
	
    



<div class="td-content" style="--base-section-num: '6.3.'; page-break-before: always">
    
  <h1 id="pg-bcb29e33caf02d50bf39e0cfeb4ecb3b">6.3 - Use of fixed strings</h1>
    
	<p>Any <code>&lt;group&gt;</code> value or <code>&lt;data&gt;</code> name and value can use references to matched content, but in addition to this it is possible just to output a known string, e.g.</p>
<pre><code class="language-xml">&lt;data name=&quot;somename&quot; value=&quot;$&quot; /&gt;
</code></pre>
<p>The above example would output <code>somename</code> as the <code>&lt;data&gt;</code> name attribute. This can often be useful where there are no headings specified in the input data but we want to associate certain names with certain values.</p>
<p>Given the following data:</p>
<pre><code class="language-csv">01/01/2010,00:00:00,192.168.1.100,SOMEHOST.SOMEWHERE.COM,user1,logon,
</code></pre>
<p>We could provide useful headings with the following configuration:</p>
<pre><code class="language-xml">&lt;regex pattern=&quot;([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),([^,]*),&quot;&gt;
  &lt;data name=&quot;date&quot; value=&quot;$1&quot; /&gt;
  &lt;data name=&quot;time&quot; value=&quot;$2&quot; /&gt;
  &lt;data name=&quot;ipAddress&quot; value=&quot;$3&quot; /&gt;
  &lt;data name=&quot;hostName&quot; value=&quot;$4&quot; /&gt;
  &lt;data name=&quot;user&quot; value=&quot;$5&quot; /&gt;
  &lt;data name=&quot;action&quot; value=&quot;$6&quot; /&gt;
&lt;/regex&gt;
</code></pre>

</div>




    
	
  
    
    
	
    



<div class="td-content" style="--base-section-num: '6.4.'; page-break-before: always">
    
  <h1 id="pg-ad6ae2faaa3721b740dceefffaf34916">6.4 - Variable reference</h1>
    
	<p>Variables are added to Data Splitter configuration using the <code>&lt;var&gt;</code> element, see <a href="../../../../docs/user-guide/data-splitter/element-reference/2-3-variables/">variables</a>. Each variable must have a unique id so that it can be referenced. References to variables have the form <code>$VARIABLE_ID$</code>, e.g.</p>
<pre><code class="language-xml">&lt;data name=&quot;$heading$&quot; value=&quot;$&quot; /&gt;
</code></pre>
<h2 id="a-namesec-3-2-1aidentification"><a name="sec-3-2-1"></a>Identification</h2>
<p>Data Splitter validates the configuration on load and ensures that all element ids are unique and that referenced ids belong to a variable.</p>
<p>A variable will only store data if it is referenced so variables that are not referenced will do nothing. In addition to this a variable will only store data for match groups that are referenced, e.g. if <code>$heading$1</code> is the only reference to a variable with an id of ‘heading’ then only data for match group 1 will be stored for reference lookup.</p>
<h2 id="a-namesec-3-2-2ascopes"><a name="sec-3-2-2"></a>Scopes</h2>
<p>Variables have two scopes which affect how data is retrieved when referenced:</p>
<ul>
<li><a href="#sec-3-2-2-1">Local scope</a></li>
<li><a href="#sec-3-2-2-2">Remote scope</a></li>
</ul>
<h3 id="a-namesec-3-2-2-1alocal-scope"><a name="sec-3-2-2-1"></a>Local Scope</h3>
<p>Variables are local to a reference if the reference exists as a descendant of the variables parent expression, e.g.</p>
<pre><code class="language-xml">&lt;split delimiter=&quot;\n&quot; &gt;
  &lt;var id=&quot;line&quot; /&gt;

  &lt;group value=&quot;$1&quot;&gt;
    &lt;regex pattern=&quot;ip=([^ ]+) user=([^ ]+)&quot;&gt;
      &lt;data name=&quot;line&quot; value=&quot;$line$&quot;/&gt;
      &lt;data name=&quot;ip&quot; value=&quot;$1&quot;/&gt;
      &lt;data name=&quot;user&quot; value=&quot;$2&quot;/&gt;
    &lt;/regex&gt;
  &lt;/group&gt;
&lt;/split&gt;
</code></pre>
<p>In the above example, matches for the outermost <code>&lt;split&gt;</code> expression are stored in the variable with the id of <code>line</code>. The only reference to this variable is in a data element that is a descendant of the variables parent expression <code>&lt;split&gt;</code>, i.e. it is nested within split/group/regex.</p>
<p>Because the variable is referenced locally only the most recent parent match is relevant, i.e. no retrieval of values by
<a href="#sec-3-2-2-2-1">iteration</a>, <a href="#sec-3-2-2-2-2">iteration offset</a> or <a href="#sec-3-2-2-2-3">fixed position</a> is applicable. These features only apply to remote variables that store multiple values.</p>
<h3 id="a-namesec-3-2-2-2aremote-scope"><a name="sec-3-2-2-2"></a>Remote Scope</h3>
<p>The <a href="../../../../docs/user-guide/data-splitter/1-2-simple-csv-example-with-heading/">CSV example with a heading</a> is an example of a variable being referenced from a remote scope.</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;dataSplitter xmlns=&quot;data-splitter:3&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;data-splitter:3 file://data-splitter-v3.0.xsd&quot; version=&quot;3.0&quot;&gt;

  &lt;!-- Match heading line (note that maxMatch=&quot;1&quot; means that only the first line will be matched by this splitter) --&gt;
  &lt;split delimiter=&quot;\n&quot; maxMatch=&quot;1&quot;&gt;

    &lt;!-- Store each heading in a named list --&gt;
    &lt;group&gt;
      &lt;split delimiter=&quot;,&quot;&gt;
        &lt;var id=&quot;heading&quot; /&gt;
      &lt;/split&gt;
    &lt;/group&gt;
  &lt;/split&gt;

  &lt;!-- Match each record --&gt;
  &lt;split delimiter=&quot;\n&quot;&gt;

    &lt;!-- Take the matched line --&gt;
    &lt;group value=&quot;$1&quot;&gt;

      &lt;!-- Split the line up --&gt;
      &lt;split delimiter=&quot;,&quot;&gt;

        &lt;!-- Output the stored heading for each iteration and the value from group 1 --&gt;
        &lt;data name=&quot;$heading$1&quot; value=&quot;$1&quot; /&gt;
      &lt;/split&gt;
    &lt;/group&gt;
  &lt;/split&gt;
&lt;/dataSplitter&gt;
</code></pre>
<p>In the above example the parent expression of the variable is not the ancestor of the reference in the <code>&lt;data&gt;</code> element. This makes the <code>&lt;data&gt;</code> elements reference to the variable a remote one. In this situation the variable knows that it must store multiple values as the remote reference <code>&lt;data&gt;</code> may retrieve one of many values from the variable based on:</p>
<ol>
<li>The match count of the parent expression.</li>
<li>The match count of the parent expression, plus or minus an offset.</li>
<li>A fixed position in the variable store.</li>
</ol>
<h4 id="a-namesec-3-2-2-2-1aretrieval-of-value-by-iteration"><a name="sec-3-2-2-2-1"></a>Retrieval of value by iteration</h4>
<p>In the above example the first line is taken then repeatedly matched by delimiting with commas. This results in multiple values being stored in the ‘heading’ variable. Once this is done subsequent lines are matched and then also repeatedly matched by delimiting with commas in the same way the heading is.</p>
<p>Each time a line is matched the internal match count of all sub expressions, (e.g. the <code>&lt;split&gt;</code> expression that is delimited by comma) is reset to 0. Every time the sub <code>&lt;split&gt;</code> expression matches up to a comma delimiter the match count is incremented. Any references to remote variables will, by default, use the current match count as an index to retrieve one of the many values stored in the variable. This means that the <code>&lt;data&gt;</code> element in the above example will retrieve the corresponding heading for each value as the match count of the values will match the storage position of each heading.</p>
<h4 id="a-namesec-3-2-2-2-2aretrieval-of-value-by-iteration-offset"><a name="sec-3-2-2-2-2"></a>Retrieval of value by iteration offset</h4>
<p>In some cases there may be a mismatch between the position where a value is stored in a variable and the match count applicable when remotely referencing the variable.</p>
<p>Take the following input:</p>
<pre><code class="language-csv">BAD,Date,Time,IPAddress,HostName,User,EventType,Detail
01/01/2010,00:00:00,192.168.1.100,SOMEHOST.SOMEWHERE.COM,user1,logon,
</code></pre>
<p>In the above example we can see that the first heading ‘BAD’ is not correct for the first value of every line. In this situation we could either adjust the way the heading line is parsed to ignore ‘BAD’ or just adjust the way the heading variable is referenced.</p>
<p>To make this adjustment the reference just needs to be told what offset to apply to the current match count to correctly retrieve the stored value. In the above example this would be done like this:</p>
<pre><code class="language-xml">&lt;data name=&quot;$heading$1[+1]&quot; value=&quot;$1&quot; /&gt;
</code></pre>
<p>The above reference just uses the match count plus 1 to retrieve the stored value. Any integral offset plus or minus may be used, e.g. [+4] or [-10]. Offsets that result in a position that is outside of the storage range for the variable will not return a value.</p>
<h4 id="a-namesec-3-2-2-2-3aretrieval-of-value-by-fixed-position"><a name="sec-3-2-2-2-3"></a>Retrieval of value by fixed position</h4>
<p>In addition to retrieval by offset from the current match count, a stored value can be returned by a fixed position that has no relevance to the current match count.</p>
<p>In the following example the value retrieved from the ‘heading’ variable will always be ‘IPAddress’ as this is the fourth value stored in the ‘heading’ variable and the position index starts at 0.</p>
<pre><code class="language-xml">&lt;data name=&quot;$heading$1[3]&quot; value=&quot;$1&quot; /&gt;
</code></pre>

</div>




    
	
  

    
	
  



          </main>
        </div>
      </div>
      
<footer class="bg-dark py-5 row d-print-none">
  <div class="container-fluid mx-sm-5">
    <div class="row">
      <div class="col-6 col-sm-4 text-xs-center order-sm-2">
        
        
        
      </div>
      <div class="col-6 col-sm-4 text-right text-xs-center order-sm-3">
        
        
        
<ul class="list-inline mb-0">
  
  <li class="list-inline-item mx-2 h3" data-toggle="tooltip" data-placement="top" title="GitHub" aria-label="GitHub">
    <a class="text-white" target="_blank" rel="noopener" href="https://github.com/gchq/stroom" aria-label="GitHub">
      <i class="fab fa-github"></i>
    </a>
  </li>
  
</ul>

        
        
      </div>
      <div class="col-12 col-sm-4 text-center py-2 order-sm-2">
        <small class="text-white">&copy; 2022 Crown Copyright All Rights Reserved</small>
        
	
      </div>
    </div>
  </div>
</footer>


    </div>
    

<script src='../../../../js/popper.min.js'></script>
<script src='../../../../js/bootstrap.min.js'></script>






<script src='../../../../js/tabpane-persist.js'></script>



















<script src="../../../../js/main.js"></script>



<script src='../../../../js/prism.js'></script>



  </body>
</html>
